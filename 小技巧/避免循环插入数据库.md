# 避免循环插入数据库

> 平常的业务中难免会涉及到循环插入，然而循环插入的性能低，容易给db带来压力
>
> 我们可以Stream流api，用一种尽可能优雅的方法防止循环插入
>
> 下面的方式，虽然能够避免循环入库，但是如果本身业务就涉及到很多表的操作，将会进一步复杂化。对于不熟悉stream流操作的人来说，代码维护起来困难。因此只有再真的非常关注性能，或者数据量足够大会影响到性能的时候，才需要进行这样的处理。

## Demo1

```java
@RestController
public class MainController {

    // 商品实体类
    @Data
    @Accessors(chain = true)
    static class Product {
        private String id;

        private String name;

        private BigDecimal price;

        private List<Image> images;
    }
    // 图片实体类
    @Data
    @Accessors(chain = true)
    static class Image {
        private String id;

        private String pid;

        private String url;
    }

    List<Product> products;

    // 模拟前端传来的数据
    public void fillData() {
        products = new ArrayList<>();
        for (int i = 0; i < 3; i++) {

            final List<Image> images = Stream.iterate(0, o -> o + 1)
                    .limit(i)
                    .map(o -> new Image().setUrl(UUID.randomUUID().toString())
                            .setId(UUID.randomUUID().toString()))
                    .collect(Collectors.toList());
            products.add(
                    new Product().setName(String.valueOf(i))
                            .setPrice(new BigDecimal(String.valueOf(Math.random() * 100)))
                            .setImages(images));
        }
    }


    /**
     * 现在我们的业务是前端传来多个商品即products
     * 我们将这些商品信息入库
     * 对于商品而言比较简单直接入库即可，但是图片与商品不在一个表中，导致图片需要商品的id
     * 平常的做法是循环插入商品，然后通过db返回的id设置图片的pid属性，再批量插入图片
     * 如果想要先批量插入商品，再批量插入图片，减少db的访问次数
     * 关键点就在于我们需要先保存商品与图片的关系，一边后面获取生成的商品id
     * 可以用如下方法
     */
    @GetMapping("/")
    public Object hello() {
        fillData();
        // 存储商品与图片的关系
        final Map<Product, List<Image>> map = products.stream()
                .collect(Collectors.toMap(p -> p, Product::getImages));

        // 提取出要插入库的实体类
        final List<Product> productList = new ArrayList<>(map.keySet());

        // 模拟db入库，获取db插入的主键
        for (Product p : productList) {
            p.setId(UUID.randomUUID().toString());
        }

        // 这里利用了stream流中操作的引用类型是浅拷贝这个特点，从而获取入库后生成的id
        // 设置好图片对应的商品id后，批量插入数据库即可
        final List<Image> imgs = map.entrySet()
                .stream()
                .map(entry -> {
                    for (Image img : entry.getValue()) {
                        img.setPid(entry.getKey().getId());
                    }
                    return entry.getValue();
                }).reduce(new ArrayList<>(), (l1, l2) -> {
                    l1.addAll(l2);
                    return l1;
                });

        return new HashMap<>() {{
            put("products", products);
            put("imgs", imgs);
        }};
    }}

```

## Demo2

```java
// 图片类
@TableName(value ="tbl_img")
@Data
@Accessors(chain = true)
public class ImgEntity implements Serializable {
    @TableId(type = IdType.AUTO)
    private Integer id;

    private String url;
}
```

```java
// 商品类
@TableName(value ="tbl_product")
@Data
@Accessors(chain = true)
public class ProductEntity implements Serializable {
    @TableId(type = IdType.AUTO)
    private Integer id;

    private String name;
}
```

```java
// 商品图片映射
@TableName(value ="tbl_product_img_relation")
@Data
@Accessors(chain = true)
public class ProductImgRelationEntity implements Serializable {
    @TableId(type = IdType.AUTO)
    private Integer id;

    private Integer pid;

    private Integer imgId;
}
```

```java
@Service
public class ProductServiceImpl extends ServiceImpl<ProductMapper, ProductEntity>
        implements ProductService {

    @Autowired
    ImgService imgService;

    @Autowired
    ProductImgRelationService relationService;

    /**
     * 循环查库
     */
    @Override
    public List<ProductVo> listProductByEach() {
        // 查询所有商品
        final List<ProductEntity> products = list();
        final List<ProductVo> productVos = products.stream().map(p -> {
            final ProductVo vo = new ProductVo();
            // !! 这里出现了循环查库
            // 查询关联的图片的id
            final List<Integer> imgIds = relationService.lambdaQuery()
                    .select(ProductImgRelationEntity::getImgId)
                    .eq(ProductImgRelationEntity::getPid, p.getId())
                    .list().stream().map(ProductImgRelationEntity::getImgId)
                    .collect(Collectors.toList());
            List<ImgEntity> imgs;
            if (imgIds.size() != 0) {
                imgs = imgService.lambdaQuery()
                        .in(ImgEntity::getId, imgIds)
                        .list();
            } else {
                imgs = new ArrayList<>();
            }
            final List<ImgVo> imgVos = imgs.stream().map(img ->
                            new ImgVo().setId(img.getId()).setUrl(img.getUrl()))
                    .collect(Collectors.toList());

            vo.setImgs(imgVos);
            vo.setId(p.getId());
            vo.setName(p.getName());

            return vo;
        }).collect(Collectors.toList());
        return productVos;
    }

    /**
     * 批量查询 + map映射
     */
    @Override
    public List<ProductVo> listProductByMap() {
        // 查询所有商品
        final List<ProductEntity> products = list();
        final List<ProductVo> productVos = products.stream().map(p ->
                        new ProductVo().setId(p.getId()).setName(p.getName()))
                .collect(Collectors.toList());

        // 查询所有商品与图片的关联
        final List<ProductImgRelationEntity> relations = relationService.list();
        // 建立 商品id--图片的映射关系
        final Map<Integer, List<Integer>> productImgMap = relations.stream()
                .collect(Collectors.groupingBy(
                        ProductImgRelationEntity::getPid,
                        Collectors.mapping(ProductImgRelationEntity::getImgId,
                                Collectors.toList())
                ));

        // 查询所有图片并建立图片id映射表
        final Map<Integer, ImgVo> imgMap = imgService.list().stream()
                .collect(Collectors.toMap(ImgEntity::getId,
                        o -> new ImgVo().setId(o.getId()).setUrl(o.getUrl())));

        for (ProductVo vo : productVos) {
            final List<Integer> imgIds = productImgMap.get(vo.getId());
            if (imgIds != null && imgIds.size() > 0) {
                vo.setImgs(
                        imgIds.stream().map(imgMap::get)
                                .collect(Collectors.toList())
                );
            }
        }
        return productVos;
    }
}
```

