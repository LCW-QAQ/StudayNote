# select	poll	epoll

1. 每个socket线程在读取文件的候, 线程都是阻塞的, 这个时期的IO是blocking-io
2. 线程在读取文件时不再阻塞, 线程循环, 观察是否读取完毕, 发现读取完毕后进行处理
    - 优点
        - 同步非阻塞 NIO
        - 非阻塞IO, 可以竟可能的利用CPU资源, 不会因IO阻塞浪费CPU资源
    - 缺点
        - 循环观察发生在用户空间, 性能低
        - 消耗的空间大, 1000个fd, 就需要1000个线程处理
3. 读取文件的操作由select来完成, 遍历所有fd, 看那个能够进行IO, 然后进行处理
    - 优点
        - select多路复用
        - 一个线程监视, 多个scoket的IO请求
        - 不需要在创建N个线程处理
    - 缺点
        - 只需要一个线程, 但是单线程可监视的fd有限
        - 有IO事件发生了, 但是不知道是哪个fd, 所以每次都需要遍历所有fd, 线性查找, 效率低
4. poll, 本质上和select是一样的, 区别就是poll使用的是链表存储fd, 没有监视数量限制
    - 优点
        - 同select
        - 没有连接数即监视fd数量上的限制, 使用链表存储
    - 缺点
        - 同样使用轮询, 线性查找, 效率低
        - 水平触发, 收到了fd消息后, 若没有被处理, 下次还会报告该fd
5. select 和 poll 只触发了一次系统调用, 由内核来完成遍历
6. epoll, 使用事件处理模型, 不同于轮询, 只会通知发生了IO事件的fd, 实际上是事件驱动的, 相当于复杂度降到了O(1)
    - 优点
        - epoll 并发限制, 连接数与内存大小有关
        - 不需要轮询, 只需要处理触发事件的fd, 通过回调函数处理
        - 有两种触发模式
            - EPOLLLT
                - 默认模式, 只要fd还有数据可以读, 每次epoll_wait, 都会返回fd的读取事件, 提醒用户去操作
            - EPOLLET
                - 边缘触发模式, 只会提示一次, 直到再有数据流入之前都不会再提示, 无论fd中是否还有数据可读, 一次把buffer读光
                - 如果系统中有我们不关心的fd, 每次epoll_wait都触发, 大大降低检索fd的性能, 当被监控的fd上发生IO事件时, 再去通知程序读写, 系统中不会充满我们不关心的就绪fd
        - epoll 只会关心活跃的连接和连接数无关, 提升检索连接性能, 性能远高于select poll
        - IO使用mmap
            - 跨过了页缓存, 减少数据从用户态到内核态的拷贝次数, 提高文件读写效率
            - 用户态到内核态高效交互, 两者的修改直接反映在自己的局域内, 及时被对方捕捉

