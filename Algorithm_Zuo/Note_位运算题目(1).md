1.**现在有一个数组, 数组中有一个数出现了奇数次, 剩下的数出现了偶数次, 求这个出现了奇数次的数**

这个题可以用Hash表来解决, 但是有更简单的方法

题目实际上考察的是位运算中的异或

题目中说**只有一个数出现了奇数次**, **其他数都出现了偶数次**

可以创建一个变量xor = 0;

异或计算原则

1. 任何数异或零都等于本身
2. 1异或0等于1
3. 0异或0等于0
4. 1异或1等于0
5. 一个数异或自己等于0
6. 异或运算满足交换律和结合律

如果用这个初始值为0的xor变量, 去数组中异或一遍, xor^(a,b,c,d.....)

除了我们要找的数, 其他数都出现了偶数次, 因此其他数先异或结果就是0, 剩下来的就是我们要找的数, 有奇数个, 因此最后异或的结果就是我们要找的数

```java
public static void test1(int[] arr){
    int xor = 0;
    for (int i = 0; i < arr.length; i++) {
        xor ^= arr[i];
    }
    System.out.println(eor);
}
```

2.**现在有一个数组, 数组中有两个数出现了奇数次, 剩下的数出现了偶数次, 求这个两个出现了奇数次的数**

这个题思路其实跟上一题类似

同样用一个xor变量, 遍历数组, 异或每个元素

得到到的结果就是, 两个出先了奇数次的数(设他们为a,b)互相异或的结果

**获取(a^b)二进制的低位的第一个1**, 那么就知道了**对于a,b两个数他们低位的一个1的位置必定不一样**

再去遍历数组找到第一个1位置符合条件的数, 用一个变量xorp异或他们, 得到的结果就是(a,b)其中一个数

**文字不太好描述, 上代码, 看看吧**

```java
public void test2(int[] arr){
    //设要找的数就是a,b
    //用来获取a^b的结果
    int xor = 0;
    //用来获取a或b的结果
    int xorp = 0;
    //遍历数组, 当循环结束时, xor == a^b
    for(int num : arr){
        xor ^= num;
    }
    //获取xor二进制低位的第一个1, 获取任意数二进制的低位第一位1只需将他自己与上自己的相反数(取反+1),不清数的可以去看看补码
    int n = xor & (-xor);
    //遍历数组找到低位第一个位置为n的数, 这个遍历运行完后xorp就是a或b
    for(int num : arr){
        //如果num & n == 1意味着num这个数二进制低位第一个1与就是n
        if(num & n == 1) xorp ^= num;
	}
    //a或b
    System.out.println(xorp);
    //(a^b) ^ (a|b)
    System.out.println(xorp ^ xor);
}
```

3.**数组中只有一个数出现了K次, 其他数都出现了M次, 求这个出现了K次的数  k < m, m > 1**

这一题无法通过简单的异或来完成

因为不能确定K,M到底出现了奇数次,偶数次

只有一个数出现了K次, 其他都出现了M次 而 K<M

建立一个int类型的数组, 长度为32(32位的数)

遍历数组中所有的数, 二进制位置上如果是1就将int数组对应位置加1

遍历数组, 如果数组位置上的数取模M结果不为0说明K位置上的数二进制这个位置为1

```java
public int test3(int[] arr, int m){
    int[] b = new int[32];
    int ans = 0;
    for(int num : arr){
        //这个数二进制的第i位, 如果是1就将b[i]++
        for(int i = 0; i < 32; i++){
            b[i] += (num >> i)&1;
        }
    }
    for(int i = 0; i < 32; i++){
        //b[i] % m != 0说明出现k次的数,第i为1
        if(b[i] % m != 0){
            //将答案的, 第i位赋值为1
            ans |= (1 << i);
        }
    }
    return ans;
}
```

