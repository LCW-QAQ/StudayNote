# 	创建线程的方式

| Method           | Describe                                               |
| ---------------- | ------------------------------------------------------ |
| 继承Thread类     | 继承重写run方法, 耦合了父类,受限于单继承,不建议使用    |
| 实现Runnable接口 | 实现run方法, Runable是可以重用, 解耦了逻辑代码和Thread |
| 使用线程池       | ...                                                    |

# synchronized

当某个方法或者某个方法块被加了sync后, 就相当于给代码加了锁(一个对象, 任意的单例对象), 只有获取锁之后才能运行代码, 

锁本身是互斥的, 一个锁只能被一个线程获取.

下面是经典的抢票和脏读案例

```java
//多线程抢票
public class TicketMachine {
    
    int count = 100;

    //加上synchronized实现数据安全
    public void sell(){
        if(count > 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+"抢到了第"+count+"张票,"+"当前剩余票数:"+--count);
        }
    }

    public static void main(String[] args) {
        TicketMachine tm = new TicketMachine();
        new Thread(() -> {
            for(int i = 0; i < 50; i++){
                tm.sell();
            }
        },"Marry").start();
        new Thread(() -> {
            for(int i = 0; i < 50; i++){
                tm.sell();
            }
        },"Jerry").start();
    }
}


```

```java
//脏读案例
public class Account {
    String name;
    Double balance;

    public synchronized void setBalance(Double balance) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.balance = balance;
    }

        public Double getBalance() {
        return balance;
    }

    public static void main(String[] args) {
        Account account = new Account();
        account.name = "杨水马";
        new Thread(() -> {
            account.setBalance(100.);
        }).start();
        new Thread(() -> {
            System.out.println("读方法没有加锁, 获取的值为:" + account.getBalance()
                    + (account.getBalance() == null ? "---程序出现了脏读" : ""));
        }).start();
        try {
            Thread.sleep(1200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(account.getBalance());
    }
}
```

- #### sync加在方法上默认锁的是this,sync可重复锁,在调用父类sync方法时,锁的还是子类的this

- #### sync中如果出现异常,程序会释放锁,如果不想释放,需要catch异常

## sync不要使用String常量,Integer,Long.....

sync锁订String常量,  可能会使其他使用到该String常量的lib出现问题

Integer..等, 在代码里做了特殊处理, 在操作时,可能改变对象信息

## sync锁升级

> JDK早起sync是重量级锁, 多线程访问时, 直接向操作系统申青进入等待队列
>
> JVM没有规定sync如何实现, 下面的案例是hotspot的sync实现

在第一个线程访问资源时, 在对象头添加一个标记, markword, 用来记录该线程的pid, 如果下一次还是同一个线程(同样的pid)来访问资源, 

那么就不用再去申请锁了, 直接访问资源 ---> **`偏向锁`**

如果第二次访问的线程不是同一线程, 那么他不会立马去操作系统的等待队列, 他会在原地等待(循环) , 在循环的没有结束之前,

如果锁被释放了, 那么该线程就可以抢锁继续执行 ---> **`自旋锁`**

等待循环10次后, 还没有获取资源, 此时就会想操作系统申请, 进入等待队列 ---> **`重量级锁`**

- **自旋锁适合于执行时间短,并且并发量不高的情况**
  - **如果并发量太高,太多线程自旋,浪费资源**
  - **如果线程执行时间长,那么自旋获取锁概率低,不适合使用自旋锁**

# volatile

**volatile关键字可以让变量在多个线程中共享(多个线程中都可见), 在任意一个线程更改变量后, 别的线程中的这个变量会立马更新**

**volatile同时也可以禁止指令重排序**



## volatile变量可见性

```java
public class VolatileVarVisible extends Thread{
    public boolean flag = true;

    public void run(){
        System.out.println("server start");
        while(flag){
            //模拟服务器运行
        }
        System.out.println("server end");
    }
    
    public static void main(String[] args) {
        VolatileVarVisible server = new VolatileVarVisible();
        //启动服务器
        server.start();
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //两秒后设置flag为false, 让服务器停止运行
        server.flag = false;
    }
}
```

上面的代码在预期中, 服务器启动,运行两秒后,应该会关闭,输出server end

但是实际执行中, 两秒后并没有关闭, 并且等待n秒后仍在运行

- **没有关闭的原因是:**
  - **这个案例中, 有一个main线程,和一个自定义的线程, 这个两个线程都要访问server对象的flag字段**
  - **JVM会将这个两个变量复制一份到各自的线程栈中, 当main方法更改flag时,更改的是自己的线程栈中的flag**
  - **然后会将flag的值同步到server对象中的flag, 但是这个操作对于另一个线程是不可见的**
  - **另一个线程并不知道flag更改了, 同时我们也无法确定它什么时候回去更新flag的数据**
  - **正因此出现了不同线程栈中的flag变量不一致的问题**
  - **为了保障操作的原子性,一致性, volatile关键字可以让对flag的操作,所有线程都可见**
  - **任意一个线程中的flag更改都会直接反映到其他线程中**

- ## volatile保证变量在多线程中是可见的, 依赖于CPU的MESI,缓存一致性协议



***这里注意编译器对不同的代码会有不同的处理***

下面的代码会正常结束, 为什么呢, 明明没有给volatile

注意, server线程不知道flag什么时候更改, 但是如果有操作触发了去更新缓存中的flag, 那么就会正常结束

这个操作可以反编译字节码看到

```java
public class VolatileVarVisible extends Thread {
    public boolean flag = true;

    public void run() {
        System.out.println("server start");
        while (flag) {
            System.out.println(flag);
        };
        System.out.println("server end");
    }

    public static void main(String[] args) {
        VolatileVarVisible server = new VolatileVarVisible();
        server.start();
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        server.flag = false;
    }
}
```

bytecode 01

```bytecode
public run()V
   L0
    LINENUMBER 7 L0
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    LDC "server start"
    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V
   L1
    LINENUMBER 8 L1
   FRAME SAME
    ALOAD 0
    GETFIELD com/lcw/volatile_demo/VolatileVarVisible.flag : Z
    IFEQ L2
    GOTO L1
   L2
    LINENUMBER 9 L2
   FRAME SAME
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    LDC "server end"
    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V
   L3
    LINENUMBER 10 L3
    RETURN
   L4
    LOCALVARIABLE this Lcom/lcw/volatile_demo/VolatileVarVisible; L0 L4 0
    MAXSTACK = 2
    MAXLOCALS = 1
```

bytecode 02

```bytecode
public run()V
   L0
    LINENUMBER 7 L0
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    LDC "server start"
    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V
   L1
    LINENUMBER 8 L1
   FRAME SAME
    ALOAD 0
    GETFIELD com/lcw/volatile_demo/VolatileVarVisible.flag : Z
    IFEQ L2
   L3
    LINENUMBER 9 L3
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    ALOAD 0
    GETFIELD com/lcw/volatile_demo/VolatileVarVisible.flag : Z
    INVOKEVIRTUAL java/io/PrintStream.println (Z)V
    GOTO L1
   L2
    LINENUMBER 11 L2
   FRAME SAME
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    LDC "server end"
    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V
   L4
    LINENUMBER 12 L4
    RETURN
   L5
    LOCALVARIABLE this Lcom/lcw/volatile_demo/VolatileVarVisible; L0 L5 0
    MAXSTACK = 2
    MAXLOCALS = 1
```

>volatile却可以停止的原因
>
>没有两个bytecode 的处理是不一样的
>
>- while循环中没有访问flag
>    - 在第11行`GETFIELD com/lcw/volatile_demo/VolatileVarVisible.flag : Z `一次
>    - 没有更新缓存
>- while循环中访问了flag
>    - 在 第11行 ` GETFIELD com/lcw/volatile_demo/VolatileVarVisible.flag : Z`后, 如果程序没有跳转到L2, 会继续执行下面的代码,  
>        需要打印变量, 第17行再次 `GETFIELD com/lcw/volatile_demo/VolatileVarVisible.flag : Z` 导致当前线程缓存中的flag变量更新

MESI中每个缓存行都有四个状态，分别是E（exclusive）、M（modified）、S（shared）、I（invalid）。下面我们介绍一下这四个状态分别代表什么意思。

M：代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中。这个状态的缓存行中的数据和内存中的不一样，在未来的某个时刻它会被写入到内存中（当其他CPU要读取该缓存行的内容时。或者其他CPU要修改该缓存对应的内存中的内容时（个人理解CPU要修改该内存时先要读取到缓存中再进行修改），这样的话和读取缓存中的内容其实是一个道理）。

E：E代表该缓存行对应内存中的内容只被该CPU缓存，其他CPU没有缓存该缓存对应内存行中的内容。这个状态的缓存行中的内容和内存中的内容一致。该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。

S:该状态意味着数据不止存在本地CPU缓存中，还存在别的CPU的缓存中。这个状态的数据和内存中的数据是一致的。当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态

|    当前状态    |                             事件                             |                             行为                             | 下一个状态 |
| :------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :--------: |
|  I（invalid）  |                          local read                          | 1.如果其他处理器中没有这份数据，本缓存从内存中取该数据，状态变为E2.如果其他处理器中有这份数据，且缓存行状态为M，则先把缓存行中的内容写回到内存。本地cache再从内存读取数据，这时两个cache的状态都变为S3.如果其他缓存行中有这份数据，并且其他缓存行的状态为S或E，则本地cache从内存中取数据，并且这些缓存行的状态变为S |    E或S    |
|                |                         local write                          | 1.先从内存中取数据，如果其他缓存中有这份数据，且状态为M，则先将数据更新到内存再读取（个人认为顺序是这样的，其他CPU的缓存内容更新到内存中并且被本地cache读取时，两个cache状态都变为S，然后再写时把其他CPU的状态变为I，自己的变为M）2.如果其他缓存中有这份数据，且状态为E或S，那么其他缓存行的状态变为I |     M      |
|  remote read   |               remote read不影响本地cache的状态               |                              I                               |            |
|  remote write  |               remote read不影响本地cache的状态               |                              I                               |            |
| E（exclusive） |                          local read                          |                           状态不变                           |     E      |
|                |                         local write                          |                          状态变为M                           |     M      |
|  remote read   |                 数据和其他核共享，状态变为S                  |                              S                               |            |
|  remote write  |                 其他CPU修改了数据，状态变为I                 |                              I                               |            |
|  S（shared）   |                          local read                          |                          不影响状态                          |     S      |
|                |                         local write                          |         其他CPU的cache状态变为I，本地cache状态变为M          |     M      |
|  remote read   |                          不影响状态                          |                              S                               |            |
|  remote write  |      本地cache状态变为I，修改内容的CPU的cache状态变为M       |                              I                               |            |
| M（modified）  |                          local read                          |                           状态不变                           |     M      |
|                |                         local write                          |                           状态不变                           |     M      |
|  remote read   | 先把cache中的数据写到内存中，其他CPU的cache再读取，状态都变为S |                              S                               |            |
|  remote write  | 先把cache中的数据写到内存中，其他CPU的cache再读取并修改后，本地cache状态变为I。修改的那个cache状态变为M |                              I                               |            |

## volatile防止指令重排

> 防止指令重排最典型的例子就是单例模式中的 双重检测

```java
public class Manager {

    private volatile static Manager instance;

    private Manager(){
        System.out.println("smm");
    }

    public static Manager getInstance(){
        if(instance == null){
            synchronized (Manager.class) {
                if(instance == null){
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    instance = new Manager();
                }
            }
        }
        return instance;
    }
}
class TestManager{
    public static void main(String[] args) {
        new Thread(() -> {
            for(int i = 0; i < 100; i++){
                Manager m = Manager.getInstance();
                System.out.println(m.hashCode());
            }
        }).start();
        new Thread(() -> {
            for(int i = 0; i < 100; i++){
                Manager m = Manager.getInstance();
                System.out.println(m.hashCode());
            }
        }).start();
    }
}
```

指令重排非常难演示出来, 他一般都只会出现在JIT优化, 或者非常非常高的并发情况下(如秒杀)

- **指令重排的概念:**
- **赋值一个变量可以分为三个步骤**
  1. **首先申请内存初始化变量,里面存放的是初始值**    &0x1025fe = init;
  2. **然后变量赋值为我们想要的值**    &0x1025fe = MyValue;
  3. **最后将指针指向该变量**   point = &0x1025fe;
  4. **在没有完成第三步的时候, 可以将point理解为point=null**
- **编译器为了优化, 可能会进行指令重排, 将第三部提前到第二步**
  - **这个时候在第二步中, point的值已经不为null了, 他指向&0x1025fe, 里面存放的是初始值**
  - **如果在执行到第二部还没有执行第三部的时候, 有一个线程进入到point == null, 此时的结果为true**
  - **这个时候获取的值是一个初始值, 如果对他进行处理就可能会影响程序逻辑,导致错误**
  - **volatile禁止指令重排就解决了该问题**

# CAS

CAS(CompareAndSwap or CompareAndSet)

CAS就是所谓的自旋锁/乐观锁

CAS是无锁并发, 因此性能高

JUC包下所有的Atomic开头的类都是CAS操作

## AtomicInteger

```java
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

public class IntegerIncrement {
    AtomicInteger count = new AtomicInteger(0);

    public void m(){
        for (int i = 0; i < 100000; i++) {
            count.incrementAndGet();
        }
    }

    public static void main(String[] args) {
        IntegerIncrement integerIncrement = new IntegerIncrement();
        List<Thread> list = new ArrayList<>();
        for(int i = 0; i < 10; i++){
            list.add(new Thread(integerIncrement::m));
        }
        list.forEach(Thread::start);
        for (Thread thread : list) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(integerIncrement.count);
    }
}
```

**CAS底层实现原理就是 判断一个值是否与预期值一致, 如果一致, 就代表当前变量没有被其他线程更改, 直接更改即可**

**到这里你可能会有疑问, 在判断是否与预期值一致时, 不会有其他线程抢占吗?**

**答案是不会, 因为这个比较的过程(CAS), 是CPU原语, 是一条原子性的指令, 不会出现线程抢占执行**

下面是AtomicInteger, incrementAndGet方法的源码, 它调用了Unsafe类中的方法

```java
/**
 * Atomically increments by one the current value.
 *
 * @return the updated value
 */
public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}
```

```java
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
        //compareAndSwap就是我们所说的CAS, 它是CPU原语, 本身就是一条CPU指令, 是原子性操作
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
```

## LongAdder

**LongAdder 适合于多线程长期增加一个值**

```java
import java.util.concurrent.atomic.LongAdder;

public class LongAdderDemo {

    static LongAdder longAdder = new LongAdder();

    public static void main(String[] args) throws InterruptedException {
        LongAdderDemo l = new LongAdderDemo();
        Thread[] threads = new Thread[1000];
        for(int i = 0; i < threads.length; i++){
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    longAdder.increment();
                }
            });
        }

        for (Thread thread : threads) {
            thread.start();
        }

        for (Thread thread : threads) {
            thread.join();
        }

        System.out.println(longAdder.longValue());
    }
}

```





## ABA问题

ABA问题是指在CAS操作前, 如果已经有一个线程, 改变了变量, 然后又改回去, 可能会出现问题

- 例子:  
  1. 现在有一个`int a = 1`, 它在CAS前, 被其他线程更改为`100`, 然后又更改为`1`, 此时CAS判断预期值一致,继续执行更改  
     在变量为基础数据类型的情况下, 其实不会产生影响, 接下来该干嘛干嘛, 但是如果变量是引用数据类型就会出现问题了
  2. 有一个Obj对象, 在CAS前, 如果更改了CAS中的值, 但是在CAS时,Obj地址没变, 因此CAS会正常执行, 这样就会出现问题了,  
     想要解决这个问题, 只需要给对象加上一个版本号version即可, 每次更改对象的任意字段时都要更改version,   
     在CAS时要同时判断`预期值`,`版本号`

# JUC中的新锁

JUC中的新锁都是QAS,CAS实现的

## ReentrantLock

**`ReentrantLock`**是一个可重入锁, 这一点和sync一致

但是ReentrantLock拥有更多新特性, 相当于sync的扩展, 他可以代替sync

### lock()

```java
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockDemo {
    static long num = 0;

    static ReentrantLock rLock = new ReentrantLock();

    static void m(){
        for(int i = 0; i < 1000; i++){
            try {
                //使用lock()方法来锁定,lock()后面的方法限相当于sync(obj){},大括号中的代码块
                rLock.lock();
                num++;
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                //一定要try finally,保证会释放锁
                if (rLock != null) {
                    rLock.unlock();
                }
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[1000];
        for(int i = 0; i < threads.length; i++){
            threads[i] = new Thread(ReentrantLockDemo::m);
        }

        for (Thread thread : threads) {
            thread.start();
        }

        for (Thread thread : threads) {
            thread.join();
        }
        System.out.println(num);
    }
}
```

### tryLock()

ReentrantLock中提供了tryLock方法, 该方法可以指定尝试获取锁的过程, 可以等待(阻塞)多少秒, 超时后直接不再等待, 可以先去左其他事

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockDemo2 {
    static long num = 0;

    static ReentrantLock lock = new ReentrantLock();

    static void m(){
        try {
            lock.lock();
            //将会锁定>=10秒
            for (int i = 0; i < 10; i++) {
                Thread.sleep(1000);
                System.out.println(Thread.currentThread().toString()+ ++num);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    static void m2(){
        boolean bool = false;
        try {
            //尝试去获取锁, 如果阻塞时间超过5秒, 将会不再阻塞, 可以去做其他事
            bool = lock.tryLock(5, TimeUnit.SECONDS);
            System.out.println(Thread.currentThread()+"m2 lock is "+bool);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            //如果获取到了锁, 就释放锁
            if(bool) {
                System.out.println(++num);
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(ReentrantLockDemo2::m, "t1");
        Thread t2 = new Thread(ReentrantLockDemo2::m2, "t2");
        //演示需要让t1先执行, 设置最大优先级, 方便测试
        t1.setPriority(Thread.MAX_PRIORITY);
        t1.start();
        t2.start();
    }
}
```

### lockInterruptibly()

ReentrantLock支持可中断锁, 这一点与sync不同, 如果线程没有获取sync锁, 会一直阻塞无法中断的

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockDemo3 {
    static ReentrantLock lock = new ReentrantLock();

    static void m(){
        try {
            lock.lock();
            System.out.println(Thread.currentThread()+"--start");
            TimeUnit.SECONDS.sleep(10);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (lock != null) {
                lock.unlock();
            }
        }
        System.out.println(Thread.currentThread()+"--end");
    }

    static void m1(){
        try {
            //设置可中断锁
            lock.lockInterruptibly();
            System.out.println(Thread.currentThread()+"end");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }finally {
            if (lock != null) {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(ReentrantLockDemo3::m, "t1");
        Thread t2 = new Thread(ReentrantLockDemo3::m1, "t2");
        t1.setPriority(Thread.MAX_PRIORITY);//需要让t1先运行,为测试创造条件,不是100%优先执行,但是比没有好
        t1.start();
        t2.start();
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("t2 will be interrupted");
        //t1会执行10秒, 如果5秒后t2还没获取锁执行, 强行中断会抛出IllegalMonitorStateException异常
        t2.interrupt();
    }
}
```

### fair

ReentrantLock支持公平锁, 设置公平锁后, lock将会创建一个线程队列, 线程在队列中有序执行, 而不是队列中的线程抢锁

```java
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockDemo4 {
    //调用boolean参数的构造方法设置为true, 就可以使用公平锁, 默认为false公平锁
    static ReentrantLock lock = new ReentrantLock(true);

    static void m1(){
        for (int i = 0; i < 10; i++) {
            try {
                lock.lock();
                Thread.sleep(1000);
                System.out.println(Thread.currentThread().getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                if (lock != null) {
                    lock.unlock();
                }
            }
        }
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(ReentrantLockDemo4::m1,"t1");
        Thread t2 = new Thread(ReentrantLockDemo4::m1,"t2");
        t1.start();
        t2.start();
        //打印的结果不一定是想象中的两个线程交替执行, 实际结果可能是下面这样:
        /*
        		t2
                t2
                t2
                ....
                t1
                t2
                t1
                t1
        */
       	//原因其实也很简单, 当t1获取锁之后执行,这个时候t2进入等待队列, 然后第二次就是t2执行,这个没有问题,
        //如果执行某次时t1获取锁执行完成后, 它立马又被CPU调度,进入等待队列,然后t2才进入队列,这个时候t1就会有执行一遍了
    }
}
```

## CountDownLatch

CountDownLatch, 可以原子性的自减, 等到自减至0的时候继续执行

```java
import java.util.concurrent.CountDownLatch;

public class CountDownLatchDemo {
    //参数列表为计数
    static final CountDownLatch latch = new CountDownLatch(1000);

    public static void main(String[] args) {
        Thread[] threads = new Thread[1000];

        for(int i = 0; i < threads.length; i++){
            threads[i] = new Thread(() -> {
                System.out.println(Thread.currentThread().getName());
                //原子性的自减
                latch.countDown();
            });
        }

        for (Thread thread : threads) {
            thread.start();
        }

        try {
            //阻塞当前线程, 直到count自减至0
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(latch.getCount());
    }
}
```

## CyclicBarrier

CyclicBarrier循环壁垒, 只有当n个线程都进入执行队列后, 才会继续执行

```java
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierDemo {
    public static void main(String[] args) {
        //第一个参数指定线程数, 第二个为回调函数
        CyclicBarrier barrier = new CyclicBarrier(20, () -> System.out.println("run..."));
        for (int i = 0; i < 100; i++){
            new Thread(() -> {
                try {
                    //如果队列中未满20, 阻塞当前线程
                    barrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

## Exchanger

Exchanger可以交换两个线程作用域中的变量

```java
import java.util.concurrent.Exchanger;

public class ExchangerDemo {
    static Exchanger<String> exchanger = new Exchanger<>();

    public static void main(String[] args) {
        for(int i = 0; i < 2; i++){
            int finalI = i;
            new Thread(() -> {
                String str = "t"+finalI;
                try {
                    //调用exchanger, 指定需要交换的变量
                    str = exchanger.exchange(str);
                    System.out.println(Thread.currentThread().getName()+"="+str);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "t"+finalI).start();
        }
    }
}
```

## Phaser

Phaser可以将线程的执行过程分为多个阶段, 只有当多有线程都执行完成一个阶段后, 才会执行下一个阶段

```java
import java.util.ArrayList;
import java.util.concurrent.Phaser;

public class PhaserDemo {

    public static void main(String[] args) {
        ArrayList<Thread> list = new ArrayList<>();
        for(int i = 0; i < 8; i++){
            String name = "t"+i;
            list.add(new Thread(new Person(name),name));
        }
        //添加两个last线程, 只有last线程才需要执行doLast()
        list.add(new Thread(new Person("lastT1"),"lastT1"));
        list.add(new Thread(new Person("lastT2"),"lastT2"));
        //注册有多少个线程
        myPhaser.bulkRegister(list.size());
        list.forEach(Thread::start);
    }
    
    static MyPhaser myPhaser = new MyPhaser();

    //自定义一个阶段执行器
    static class MyPhaser extends Phaser{
        //方法返回值为true就会结束线程
        @Override
        protected boolean onAdvance(int phase, int registeredParties) {
            //phase每过一个阶段就会自增, 第一个阶段默认为0, 依次类推, 1,2...n
            switch (phase){
                case 0:
                    System.out.println("step one complete! Current nums of Threads:"+registeredParties+"\r\n");
                    return false;
                case 1:
                    System.out.println("step two complete! Current nums of Threads:"+registeredParties+"\r\n");
                    return false;
                case 2:
                    System.out.println("step Three complete! Current nums of Threads:"+registeredParties+"\r\n");
                    return false;
                case 3:
                    System.out.println("step Last complete! Current nums of Threads:"+registeredParties+"\r\n");
                    return true;
                default:
                    return true;
            }
        }
    }

    static void millisSleep(long millis){
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    //自定义一个Person, 有四个阶段的执行方法
    static class Person implements Runnable{
        String name;

        public Person(String name){this.name = name;}

        public void doOne(){
            millisSleep((long) (Math.random() * 1000));
            System.out.println(Thread.currentThread().getName()+"=step One");
            //到达当前阶段, 等待其他线程执行完成后, 才会进入下一个阶段继续执行
            myPhaser.arriveAndAwaitAdvance();
        }

        public void doTwo(){
            millisSleep((long) (Math.random() * 1000));
            System.out.println(Thread.currentThread().getName()+"=step Two");
            myPhaser.arriveAndAwaitAdvance();
        }

        public void doThree(){
            millisSleep((long) (Math.random() * 1000));
            System.out.println(Thread.currentThread().getName()+"=step Three");
            myPhaser.arriveAndAwaitAdvance();
        }

        public void doLast(){
            if(name.startsWith("last")){
                millisSleep((long) (Math.random() * 1000));
                System.out.println(Thread.currentThread().getName()+"=step Last");
                myPhaser.arriveAndAwaitAdvance();
            }else {
                //如果不是last线程, 到这一步的时候就会停止, 不会继续执行
                myPhaser.arriveAndDeregister();
            }
        }

        //线程执行的四个阶段
        @Override
        public void run() {
            doOne();
            doTwo();
            doThree();
            doLast();
        }
    }
}
```

## ReadWriteLock

```java
import java.util.Random;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockDemo {
    static int value = 0;

    //普通的可重入锁
    static Lock lock = new ReentrantLock();

    //读写锁
    static ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    //读锁
    static Lock readLock = readWriteLock.readLock();
    //写锁
    static Lock writeLock = readWriteLock.writeLock();

    //读取value的方法, 传入一个lock, 对比ReentrantLock和ReadWriteLock的效率
    static void read(Lock lock){
        try {
            lock.lock();
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName()+": value="+value);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (lock != null) {
                lock.unlock();
            }
        }
    }

    static void write(Lock lock, int newValue){
        try {
            lock.lock();
            System.out.println(Thread.currentThread().getName()+"value = "+(value = newValue));
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (lock != null) {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        //使用读写锁, 大幅提高读取性能
        for(int i = 0; i < 18; i++){
            new Thread(() -> read(readLock)).start();
        }
        for(int i = 0; i < 2; i++){
            new Thread(() -> write(writeLock, new Random().nextInt())).start();
        }
        //使用普通的Reentrant
        /*for(int i = 0; i < 18; i++){
            new Thread(() -> read(lock)).start();
        }
        for(int i = 0; i < 2; i++){
            new Thread(() -> write(lock,new Random().nextInt())).start();
        }*/
    }
}
```

## StampedLock

StampedLock是jdk1.8的新锁, 该锁是ReadWriteLock的增强版, 支持读写锁的互相转化,比RWL更加灵活

```java
import java.util.concurrent.locks.StampedLock;

public class StampedLockDemo2 {

    public static void main(String[] args) {
        Point point = new Point(10.,10.);
        for (int i = 0; i < 10; i++) {
            int finalI = i;
            new Thread(() -> {
                point.move(finalI,finalI);
            }).start();
        }
        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                System.out.println(point.distanceFromOriginByOptimisticRead());
            }).start();
        }
    }

    static class Point{
        private Double x,y;
        private StampedLock lock = new StampedLock();

        public Point(){}

        public Point(Double x, Double y) {
            this.x = x;
            this.y = y;
        }

        //改变Point的位置
        public void move(double x, double y){
            //获取writeLock, 该方法返回一个可以用户释放锁的邮戳(印记, 标记...)
            long stamp = lock.writeLock();
            try {
                this.x = x;
                this.y = y;
                System.out.println(this);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlockWrite(stamp);
            }
        }

        //返回距离原点的距离, 使用普通读锁
        public double distanceFromOriginByReadLock(){
            long stamp = lock.readLock();
            double curX = 0,curY = 0;
            try {
                curX = this.x;
                curY = this.y;
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock(stamp);
            }
            return Math.sqrt(curX * curX + curY * curY);
        }

        //返回距离原点的距离
        //使用乐观读锁, 需要拷贝一份变量到方法栈, 因此我们操作的不一定是最新的数据, 但是数据仍保持一致性
        public double distanceFromOriginByOptimisticRead(){
            //获取乐观读锁
            long stamp = lock.tryOptimisticRead();
            double curX = x, curY = y;
            //validate方法如果有人获取了独占锁(写锁),别的线程在写入数据,就可能出现数据不一致,需要切换到普通读锁
            if(lock.validate(stamp)){
                stamp = lock.readLock();
                try {
                    curX = x;
                    curY = y;
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock(stamp);
                }
            }
            return Math.sqrt(curX * curX + curY * curY);
        }

        public void moveIfAtOrigin(double x, double y){
            long stamp = lock.readLock();
            //循环判断point是否是原点
            // 必须使用循环, 不能使用if, 因为if条件成立后, 有可能有线程更改了point,不再去判断一次的话,就不符合要求了
            try {
                while(this.x == 0 && this.y == 0){
                    //前面获取的是写锁, 现在需要获取读锁, 读锁转换为写锁, 返回0代表转换失败
                    long wStamp = lock.tryConvertToWriteLock(stamp);
                    //转换成功,后就写入数据
                    if(wStamp != 0){
                        this.x = x;
                        this.y = y;
                        //成功写入数据,停止循环
                        break;
                    }else {
                        //转换失败
                        //释放读锁
                        lock.unlockRead(stamp);
                        //无法转换, 释放读锁, 重新申请一个写锁
                        stamp = lock.writeLock();
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                //无法确定最后是什么锁, 所以直接调用unlock
                lock.unlock(stamp);
            }
        }

        @Override
        public String toString() {
            return "Point{" +
                    "x=" + x +
                    ", y=" + y +
                    '}';
        }
    }
}
```



## Semaphore

Semaphore信号锁

```java
import java.util.ArrayList;
import java.util.concurrent.Semaphore;

public class SemaphoreDemo {
    //传入一个int permits, 允许多少线程可以一起执行
    static Semaphore semaphore = new Semaphore(2);

    public static void main(String[] args) {
        ArrayList<Thread> list = new ArrayList<>();
        for(int i = 0; i < 5; i++){
            list.add(new Thread(() -> {
                try {
                    //获取锁
                    semaphore.acquire();
                    for(int j = 0; j < 5; j++){
                        Thread.sleep(300);
                        System.out.println(Thread.currentThread().getName()+": run...");
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    //释放锁
                    semaphore.release();
                }
            }));
        }
        list.forEach(Thread::start);
    }
}
```

## LockSupport工具

LockSupport是JUC中的工具类, 可以方便的阻塞指定的线程

```java
import java.util.concurrent.locks.LockSupport;

public class LockSupportDemo {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                //i==5时阻塞当前线程
                if(i == 5){
                    System.out.println("park");
                    LockSupport.park();
                }
                System.out.println(i);
                try {
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        t1.start();
        //这里也可以提前unpark, 如果提前unpark, 后面的的park就会失效
        //LockSupport.unpark(t1);
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //5秒后唤醒t1
        LockSupport.unpark(t1);
    }
}
```

# 面试题(1)

## 两个线程之间的监控与同步容器

**实现一个容器,提供两个方法add,size
现在有连个线程, 线程1添加10个元素到容器里, 线程2实现监控元素的个数, 当元素个数到达5个时, 线程2给出提示并结束**

### 方式一

思路: 利用线程的通信方法, 监听线程一开始就进入阻塞状态, 添加元素至5个时唤醒监听线程

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class QuestionOneDemo5Finish {

    volatile List list = Collections.synchronizedList(new ArrayList<>());

    public void add(Object value){
        list.add(value);
    }

    public int size(){
        return list.size();
    }
    
    public static void main(String[] args){
        QuestionOneDemo5Finish qo = new QuestionOneDemo5Finish();
        Object lock = new Object();
        new Thread(() -> {
            synchronized(lock){
                System.out.println("监听线程t2启动");
                try {
                    //直接进入阻塞, 等待唤醒
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("监听到集合元素已满5个");
                //唤醒添加线程
                lock.notify();
                System.out.println("t2 end");
            }
        }, "t2").start();
        
        new Thread(() -> {
            synchronized(lock){
                System.out.println("");
                for(int i = 0; i < 10; i++){
                    qo.add(new Object());
                    System.our.println("add "+i);
                    if(qo,size() == 5){
                        lock.notify();
                        try {
                            //这里一定要让t1进入阻塞状态, notify方法是不会释放锁的, 所以哪怕调用了notify
                            //t2还是会等到, t1执行完释放锁后, 获取锁执行, 为了避免这种情况
                            //t1调用wait方法, 释放锁, 让t2获取锁执行
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
                System.out.println("t1 end");
            }
        }, "t1").start();
    }
}
```

### 方式二

思路: 无论使用什么方法其实就是要让, t2阻塞, 等待t1的通知, 任何满足要求的锁都能完成该功能, 下面是使用CountDownLatch的Demo

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CountDownLatch;

public class QuestionOneDemo6Finish {
    volatile List list = Collections.synchronizedList(new ArrayList<>());
    CountDownLatch count = new CountDownLatch(1);
    CountDownLatch tCount = new CountDownLatch(1);
    public void add(Object o){
        list.add(o);
    }

    public int size(){
        return list.size();
    }

    public static void main(String[] args) {
        QuestionOneDemo6Finish qo = new QuestionOneDemo6Finish();
        new Thread(() -> {
            try {
                //等待t1唤醒
                qo.count.await();
                System.out.println("ok!");
                qo.tCount.countDown();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
   
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                qo.add(new Object());
                System.out.println("add "+i);
                if(qo.size() == 5){
                    //自减count, 触发栅栏
                    qo.count.countDown();
                    try {
                        //自己进入阻塞, 等待t2唤醒
                        qo.tCount.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }

}

```

### 方式三

思路: 使用LockSupport更加方便的阻塞/唤醒线程, 在添加到5个元素后, 唤醒另一个线程

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.locks.LockSupport;

public class QuestionOneDemo1Finish {
    //volatile保障list在多线程中的可见性
    //ArrayList不是线程同步的, 使用Collections.synchronizedList()获取同步容器
    volatile List list = Collections.synchronizedList(new ArrayList<>());

    //使用了同步容器, 下面两个方法不许要sync了
    public void add(Object obj){
        list.add(obj);
    }
    
    public int size(){
        return list.size();
    }

    static Thread t1,t2;

    public static void main(String[] args) {
        QuestionOneDemo1Finish qo = new QuestionOneDemo1Finish();
        t2 = new Thread(() -> {
            //t2线程需要监控t1,所以让t2线程一上来就直接阻塞, 等待t1唤醒
            LockSupport.park();
            System.out.println("t2 end");
            //t2反馈完成, 唤醒t1
            LockSupport.unpark(t1);
        });
        t1 = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                qo.add(new Object());
                System.out.println("add " + i);
                if (qo.size() == 5) {
                    //满足题目条件, size == 5时, 唤醒t2线程
                    LockSupport.unpark(t2);
                    //唤醒t2线程需要让自己阻塞, 不然有可能在t2线程运行之前
                    //t1先执行后面的步骤, 题目要求是在size==5时, t2给与反馈
                    LockSupport.park();
                }
            }
        });
        //不需要关心t1,t2的启动顺序,t2只要park了就会阻塞, t1总是会在unPark(t2)后阻塞,等待t2执行然后unPark(t1)
        t1.start();
        t2.start();
    }
}
```

## 生产者消费者问题与自定义同步容器

**写一个固定容量的同步容器, 拥有put和get,以及getCount方法, 能够支持2个生产者线程以及10个消费者线程的阻塞调用**

### 方式一 Sync实现

```java
import java.util.LinkedList;
import java.util.concurrent.TimeUnit;

public class QTwoDemo1Finish {

    public static void main(String[] args) {
        Repository<String> re = new Repository<>();
        //启动消费者线程
        for(int i=0; i<10; i++) {
            new Thread(()->{
                for(int j=0; j<5; j++) System.out.println(re.get());
            }, "consumer" + i).start();
        }

        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        //启动生产者线程
        for(int i=0; i<2; i++) {
            new Thread(()->{
                for(int j=0; j<25; j++) re.put(Thread.currentThread().getName() + " " + j);
            }, "producer" + i).start();
        }
    }

    static class Repository<T> {
        private final LinkedList<T> list = new LinkedList<>();
        private final int MAX = 10;
        private int count;

        public synchronized void put(T t){
            //这里必须使用, while,不能使用if, 使用if,判断成立后可能有其他线程影响了size
            while(list.size() == MAX){
                try {
                    //生产队列满了, 进入阻塞, 等待消费者消费后唤醒
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            list.add(t);
            count++;
            //生产了新的产品, 唤醒consumer消费
            this.notifyAll();
            System.out.println(Thread.currentThread().getName()+"号生产者: "+count);
        }

        public synchronized T get(){
            //同上必须使用while
            while(list.size() == 0){
                try {
                    //阻塞等待生产者生产新产品后唤醒
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = list.removeFirst();
            count--;
            //唤醒producer
            this.notifyAll();
            return t;
        }
    }
}
```

### 方式二 ReentrantLock and Condition

方式一种notifyAll() 会唤醒其他所有线程, 不能精确控制, 唤醒的线程, ReentrantLock提供了Condition, 定义不同的线程队列, 更细粒度的控制线程

```java
package lcw.interview_question;

import java.util.LinkedList;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class QTwoDemo2Finish {
    static class Repository<T>{
        private LinkedList<T> list = new LinkedList<>();
        private final int MAX = 10;
        private int count;
        //声明可重入锁
        private ReentrantLock lock = new ReentrantLock();
        //创建不同的线程队列
        private Condition producer = lock.newCondition();
        private Condition consumer = lock.newCondition();
        
     	public void put(T t){
            //获取锁
            try {
                lock.lock();
                while(list.size() == MAX){
                    try {
                        //进入生产者阻塞队列
                        producer.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                list.add(t);
                count++;
                //唤醒消费者队列
                consumer.signalAll();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }  
        
        public T get(){
            T t = null;
            try {
                lock.lock();
                while(list.size() == 0){
                    try {
                        //进入消费者阻塞队列
                        consumer.await();
                    } catch (InterruptedException e){
                        e.printStackTrace();
                    }
                }
                t = list.removeFirst();
                count--;
                //唤醒生产者队列
                producer.signalAll();
            } catch (Exception e){
                e.printSStackTrace();
            } finally {
                lock.unlock();
            }
            return t;
        }
    }
}

```

# ThreadLocal

ThreadLocal 可以为每个**线程**创建**自己作用域内的变量**

 实际上就是在每个Thread的**ThreadLocalMap.threadLocals**变量, 存储以**ThreadLocal为Key**, 存储对象为**Value**的键值对

- ThreadLocal最典型的应用就是在Spring的声明式事务中}
  - Spring必须保证在同一个事务内的连接不会变 (不同连接还谈什么事务)
  - Spring首先从连接池中获取了一个连接
  - 但是只有这个线程当前这个线程需要连接对象, 也就是说连接对象是不需要在线程中共享的
  - 可以将这个连接设置为当前线程的ThreadLocal变量, 只在当前线程中可以读取到这个变量

> 在Java的多线程编程中，为保证多个线程对共享变量的安全访问，通常会使用synchronized来保证同一时刻只有一个线程对共享变量进行操作。
>
> 这种情况下可以将[类变量]放到ThreadLocal类型的对象中，使变量在每个线程中都有独立拷贝
>
> 不会出现一个线程读取变量时而被另一个线程修改的现象。
>
> 最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等。

```java
public class ThreadLocalDemo {

    static ThreadLocal<Person> tl = new ThreadLocal<>();

    public static void main(String[] args) {
        new Thread(() -> {
            //t1线程中的tl创建了一个Person对象
            tl.set(new Person());
            System.out.println(tl.get());
        }, "t1").start();

        new Thread(() -> {
            //t2线程等待t1线程1秒, 保证t1已经创建Person对象
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //t2在t1已经创建变量后, 尝试获取tl中的对象(获取不到)
            System.out.println(tl.get());
        }, "t2").start();
    }

    static class Person {
        String name = "zhangsan";

        public String toString() {
            return "Person { " + name + " }";
        }
    }
}
```

# Java的引用

- 强引用
- 软引用
- 弱引用
- 虚引用

## 强引用

强引用就是我们平常使用的引用, 只要创建的**对象还有引用指向它**,  它就**不会被gc回收**

```java
public class StrongReferenceDemo {
    public static void main(String[] args) {
        Person person = new Person();
        //手动gc
        System.gc();
        //打印结果发现person没有被gc回收
        System.out.println(person);
    }

    static class Person {
        String name = "zhangsan";

        @Override
        public String toString() {
            return "Person{" +
                    "name='" + name + '\'' +
                    '}';
        }
    }
}
```

## 软引用

软引用只有在**虚拟机内存不够**用的时候才会回收

软引用的特性让它 在**缓存**上 应用广泛

```java
public class SoftReferenceDemo {

    // 该demo需要加上虚拟机设置: -Xms20m -Xmx20m, 初始容量与最大容量都是20mb
    public static void main(String[] args) {
        // 软引用只有在虚拟机内存不够用的时候才会回收
        // 软引用指向一个10MB的byte数组
        SoftReference<byte[]> softRe = new SoftReference<>(new byte[1024 * 1024 * 10]);
        // 输入数组的地址
        System.out.println(softRe.get());
        // 手动gc
        System.gc();
        // 输入数组的地址, 发现不会被gc回收
        System.out.println(softRe.get());

        // 再次创建一个15mb的数组
        byte[] arr = new byte[1024 * 1024 * 15];
        // 获取软引用指向的值, 这个时候会发现, 输入null
        System.out.println(softRe.get());
    }
}
```

## 弱引用

只要**gc发现弱引用**就会**直接回收**

```java
public class WeakReferenceDemo {
    public static void main(String[] args) {
        WeakReference<Person> weakRe = new WeakReference<Person>(new Person());
        System.out.println(weakRe.get());
        System.gc();
        // person已经被回收了
        System.out.println(weakRe.get());
    }

    static class Person {
        @Override
        protected void finalize() throws Throwable {
            System.out.println(hashCode()+"--被回收了");
        }
    }
}
```

## 虚引用

只要**gc发现虚引用**就会**直接回收**, 并且**将对象放到引用队列**

```java
public class PhantomReferenceDemo {

    // 虚引用与弱引用类似, 虚引用被gc发现时, 直接回收, 并且将回收的对象装到引用队列中
    public static void main(String[] args) throws IOException {
        List<Object> list = new ArrayList<>();
        // 虚引用必须要和引用队列组合使用
        ReferenceQueue<List<Object>> reQueue = new ReferenceQueue<>();
        PhantomReference<List<Object>> phantomRe = new PhantomReference<>(list, reQueue);

        // 这个线程死循环, 监测是否有虚引用被回收, 然后装到引用队列
        new Thread(() -> {
            while (true) {
                // 尝试获取引用度列中的值
                Reference<? extends List<Object>> poll = reQueue.poll();
                if (poll != null) {
                    System.out.println("虚引用对象被回收" + poll);
                    System.out.println("虚引用对象: " + poll.get());
                }
            }
        }).start();

        // list被强引用指向无法被回收, 我们帮助gc, 置空强引用
        list = null;

        System.gc();

        System.in.read();
    }
}
```

# JUC中的新容器

## Map

### SynchronizedHashMap

普通的HashMap不是线程安全的, 但是Jdk为我们提空了Collections工具类, Collections有可以将非同步集合转换成同步集合的方法

> 下面这个程序模拟一百个线程, 同时分段向容器读写数据

**SynchronizedMap**方法, 是直接将Map的**每个方法加了锁**, 并没有使用CAS, 所以在**高并发读取时性能不高**

```java
public class SynchronizedHashMapDemo {
    // 有多少个数据需要插入
    static final int DATA_COUNT = 10000000;

    static final int THREAD_COUNT = 100;

    static Thread[] producerThread = new Thread[THREAD_COUNT];

    static Thread[] consumerThread = new Thread[THREAD_COUNT];

    static Map<UUID, UUID> map = Collections.synchronizedMap(new HashMap<>());

    // 线程分块读写, 每块的长度
    static final int BLOCK_SIZE = DATA_COUNT / THREAD_COUNT;

    //需要存入的键值
    static UUID[] keys = new UUID[DATA_COUNT];
    static UUID[] values = new UUID[DATA_COUNT];

    static class Producer extends Thread {

        int start;

        int BLOCK_SIZE = DATA_COUNT / THREAD_COUNT;

        @Override
        public void run() {
            for (int i = start; i < start + BLOCK_SIZE; i++) {
                map.put(keys[i], values[i]);
            }
        }
    }

    static class Consumer extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 1000000; i++) {
                map.get(keys[i]);
            }
        }
    }

    static {
        //初始化UUID
        for (int i = 0; i < DATA_COUNT; i++) {
            keys[i] = UUID.randomUUID();
            values[i] = UUID.randomUUID();
        }

        //初始化Producer线程
        for (int i = 0; i < producerThread.length; i++) {
            producerThread[i] = new Producer();
        }

        //初始化Consumer线程
        for (int i = 0; i < consumerThread.length; i++) {
            consumerThread[i] = new Consumer();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        System.out.println("写入开始..");
        long time = System.currentTimeMillis();
        for (int i = 0; i < producerThread.length; i++) {
            producerThread[i].start();
        }

        for (int i = 0; i < producerThread.length; i++) {
            producerThread[i].join();
        }
        System.out.println(map.size());
        long endTime = System.currentTimeMillis() - time;
        System.out.println("写入结束.. 耗时: "+endTime);

        System.out.println();

        System.out.println("读取开始..");
        time = System.currentTimeMillis();
        for (int i = 0; i < consumerThread.length; i++) {
            consumerThread[i].start();
        }

        for (int i = 0; i < consumerThread.length; i++) {
            consumerThread[i].join();
        }
        endTime = System.currentTimeMillis() - time;
        System.out.println("读取结束.. 耗时: " + endTime);
    }
}
```

### ConcurrentHashMap

下面的程序同上, 模拟一百个线程, 分段读写数据, 这次使用了ConcurrentHashMap并发容器

**ConcurrentHashMap**容器使用的是CAS, 因此高并发读取性能极高

```java
public class ConcurrentHashMapDemo {
    // 有多少个数据需要插入
    static final int DATA_COUNT = 10000000;

    static final int THREAD_COUNT = 100;

    static Thread[] producerThread = new Thread[THREAD_COUNT];

    static Thread[] consumerThread = new Thread[THREAD_COUNT];

    static ConcurrentHashMap<UUID, UUID> map = new ConcurrentHashMap<>();

    // 线程分块读写, 每块的长度
    static final int BLOCK_SIZE = DATA_COUNT / THREAD_COUNT;

    //需要存入的键值
    static UUID[] keys = new UUID[DATA_COUNT];
    static UUID[] values = new UUID[DATA_COUNT];

    static class Producer extends Thread {

        int start;

        int BLOCK_SIZE = DATA_COUNT / THREAD_COUNT;

        @Override
        public void run() {
            for (int i = start; i < start + BLOCK_SIZE; i++) {
                map.put(keys[i], values[i]);
            }
        }
    }

    static class Consumer extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 1000000; i++) {
                map.get(keys[i]);
            }
        }
    }

    static {
        //初始化UUID
        for (int i = 0; i < DATA_COUNT; i++) {
            keys[i] = UUID.randomUUID();
            values[i] = UUID.randomUUID();
        }

        //初始化Producer线程
        for (int i = 0; i < producerThread.length; i++) {
            producerThread[i] = new Producer();
        }

        //初始化Consumer线程
        for (int i = 0; i < consumerThread.length; i++) {
            consumerThread[i] = new Consumer();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        System.out.println("写入开始..");
        long time = System.currentTimeMillis();
        for (int i = 0; i < producerThread.length; i++) {
            producerThread[i].start();
        }

        for (int i = 0; i < producerThread.length; i++) {
            producerThread[i].join();
        }
        System.out.println(map.size());
        long endTime = System.currentTimeMillis() - time;
        System.out.println("写入结束.. 耗时: "+endTime);

        System.out.println();

        System.out.println("读取开始..");
        time = System.currentTimeMillis();
        for (int i = 0; i < consumerThread.length; i++) {
            consumerThread[i].start();
        }

        for (int i = 0; i < consumerThread.length; i++) {
            consumerThread[i].join();
        }
        endTime = System.currentTimeMillis() - time;
        System.out.println("读取结束.. 耗时: " + endTime);
    }
}
```

## List

### SynchronizedList

```java
public class SynchronizedListDemo {
    static List<String> list = Collections.synchronizedList(new ArrayList<>());

    static Thread[] consumers = new Thread[10];

    static {
        for (int i = 0; i < 100000; i++) {
            list.add("第" + i + "张票");
        }

        for (int i = 0; i < consumers.length; i++) {
            consumers[i] = new Thread(() -> {
                while (true) {
                    String remove;
                    // 还要单独加上锁, 虽然list的方法是原子性的, 但是整个判断和删除的操作不是原子性的
                    // 所以这里并不适合使用SyncList
                    synchronized (SynchronizedListDemo.class) {
                        if (list.size() == 0) break;
                        remove = list.remove(0);
                        System.out.println(remove);
                    }
                }
            });
        }
    }

    public static void main(String[] args) {
        for (Thread consumer : consumers) {
            consumer.start();
        }
    }
}
```

### ConcurrentLinkedQueue

```java
public class ConcurrentLinkedQueueDemo {
    static Thread[] threads = new Thread[10];

    static ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();

    static {
        for (int i = 0; i < 100000; i++) {
            queue.offer("第" + i + "张票");
        }

        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(() -> {
                while (true) {
                    String str;
                    if((str = queue.poll()) == null) break;
                    else System.out.println(str);
                }
            });
        }
    }

    public static void main(String[] args) {
        Arrays.stream(threads).forEach(Thread::start);
    }
}
```

### CopyOnWriteArrayList

> CopyOnWriteArrayList也是线程安全的, 适合大量读, 少量写, 并且数据量不大的场景
>
> 顾名思义在需要写入时, 将数据复制一份, 写入的时候在复制的数据上进行, 读取在原先的List上进行, 最后将引用指向新的List

```java
public class CopyOnWriteArrayListDemo {
    static Thread[] threads = new Thread[100];

    static CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    list.add(j);
                }
            });
        }

        for (Thread thread : threads) {
            thread.start();
        }

        for (Thread thread : threads) {
            thread.join();
        }

        System.out.println(list.size());
    }
}
```

### LinkedBlockingQueue

> LinkedBlocingQueue有一个特别的方法put, put方法在存放数据时, 会判断容器是否已满, 如果满了就阻塞, 等待可以存放数据
>
> 同样也拥有一个take方法, 如果拿不到数据, 容器空了, 就阻塞, 等待到可以拿到数据
>
> 这个容器是没有固定容量的, 如果需要固定容量, 就使用ArrayBlockingQueue

```java
public class LinkedBlockingQueueDemo {
    static LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

    static class Producer extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 100; i++) {
                try {
                    queue.put(i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    static class Consumer extends Thread {

        public Consumer() {
        }

        public Consumer(String name) {
            super(name);
        }

        @Override
        public void run() {
            for(;;) {
                try {
                    System.out.println("Consumer-"+Thread.currentThread().getName()+" take : " + queue.take());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) {
        new Producer().start();

        for (int i = 0; i < 10; i++) {
            new Consumer(String.valueOf(i)).start();
        }
    }
}
```

### ArrayBlockingQueue

```java
public class ArrayBlockingQueueDemo {
    static ArrayBlockingQueue<Integer> queue = new ArrayBlockingQueue<>(100000);

    static int count;

    static class Producer extends Thread {
        @Override
        public void run() {
            for (;;) {
                try {
                    queue.put(queue.size());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    static class Consumer extends Thread {

        public Consumer() {
        }

        public Consumer(String name) {
            super(name);
        }

        @Override
        public void run() {
            for(;;) {
                try {
                    System.out.println("Consumer-"+Thread.currentThread().getName()+" take : " + queue.take());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) {
        new Producer().start();

        for (int i = 0; i < 10000; i++) {
            new Consumer(String.valueOf(i)).start();
        }
    }
}
```

### PriorityQueue

> PriorityQueue是优先级队列, 存放的元素拥有优先级, 需要元素实现Comparable, 接口

```java
public class PriorityQueueDemo {
    static PriorityQueue<Integer> queue = new PriorityQueue<>();

    public static void main(String[] args) {
        queue.offer(2);
        queue.offer(1);
        queue.offer(3);
        queue.offer(0);
        int len = queue.size();
        for (int i = 0; i < len; i++) {
            System.out.println(queue.poll());
        }

    }
}
```

### DelayQueue

> DelayQueue可以做到定时执行任务的任务队列

```java
public class DelayQueueDemo {
    static DelayQueue<MyTask> queue = new DelayQueue<>();

    static class MyTask implements Delayed {
        String name;
        long timeStamp;

        public MyTask(String name, long timeStamp) {
            this.name = name;
            this.timeStamp = timeStamp;
        }

        @Override
        public long getDelay(TimeUnit unit) {
            return unit.convert(timeStamp - System.currentTimeMillis(), TimeUnit.MILLISECONDS);
        }

        @Override
        public int compareTo(Delayed o) {
            long a = getDelay(TimeUnit.MILLISECONDS);
            long b = o.getDelay(TimeUnit.MILLISECONDS);
            if (a < b) {
                return -1;
            } else if (a > b) {
                return 1;
            } else {
                return 0;
            }
        }

        @Override
        public String toString() {
            return "MyTask{" +
                    "name='" + name + '\'' +
                    ", timeStamp=" + timeStamp +
                    '}';
        }
    }

    public static void main(String[] args) throws InterruptedException {
        long now = System.currentTimeMillis();
        MyTask myTask1 = new MyTask("1", now + 1000);
        MyTask myTask2 = new MyTask("2", now + 2000);
        MyTask myTask3 = new MyTask("3", now + 1500);
        MyTask myTask4 = new MyTask("4", now + 300);
        MyTask myTask5 = new MyTask("5", now + 500);
        MyTask myTask6 = new MyTask("6", now + 10000);
        MyTask myTask7 = new MyTask("7", now + 15000);

        queue.addAll(List.of(myTask1, myTask2, myTask3, myTask4, myTask5, myTask6, myTask7));

        System.out.println(queue);

        int len = queue.size();
        ;
        for (int i = 0; i < len; i++) {
            System.out.println(queue.take());
        }
    }
}
```

### SynchronousQueue

> SynchronousQueue也是阻塞队列
>
> 在多线程中进行数据交换, 调用put方法后会阻塞, 等待put的元素被另一个线程take, take同样会等待, 有元素被put

```java
public class SynchronousQueueDemo {
    static SynchronousQueue<Integer> queue = new SynchronousQueue<>();

    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            try {
                System.out.println(queue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();

        for (int i = 1; i < 5; i++) {
            new Thread(() -> {
                try {
                    System.out.println(queue.take());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
        }

        queue.put(1);
        queue.put(4);
        queue.put(3);
        queue.put(5);
        queue.put(2);

        System.out.println("queue的size为: " + queue.size());
    }
}
```

### TransferQueue

> TransferQueue与SynchronousQueue类似, 都拥有多线程传递数据的特点
>
> 但是TransferQueue可以调用tryTransfer方法, 如果有线程需要就给它, 没有的话自己也不会进入阻塞队列

```java
public class TransferQueueDemo {
    static LinkedTransferQueue<Integer> queue = new LinkedTransferQueue<>();

    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            try {
                System.out.println(queue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();

        queue.transfer(1);
        queue.tryTransfer(2);
//        queue.transfer(2);
//        queue.transfer(3);
    }
}
```

# 关于线程任务的新接口

## Callable

> callable需要配合线程池使用

```java
public class CallableDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Callable<Integer> call = new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                return 1;
            }
        };

        ExecutorService service = Executors.newCachedThreadPool();
        Future<Integer> result = service.submit(call);
        
        System.out.println(result.get());
        
        service.shutdown();
    }
}
```

## Future

> Future 就是一个Callable执行的结果封装的对象, 可以获取执行的结果

## FutureTask

> FutureTask 实现了 RunnableFuture 接口, 而RunnableFuture接口继承了Runnable 和 Future 
>
> 所以FutureTask是一个可以被线程池执行的任务, 同时也是任务执行的结果
>
> 可以通过FutureTask获取执行的结果

```java
public class FutureTaskDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask<Integer> ft = new FutureTask<Integer>(() -> {
            return 1;
        });

        ExecutorService service = Executors.newCachedThreadPool();
        service.submit(ft);
    
        System.out.println(ft.get());

        service.shutdown();
    }
}
```

## CompletableFuture

> CompletableFuture是JDK线程接口中最强大的接口之一
>
> 他让JDK真正方便, 快捷, 的实现了异步操作
>
> 并且可以管理异步执行的结果

```java
public class CompletableFutureDemo_01 {
    public static void main(String[] args) throws IOException {
        // 提交一个异步任务
        CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 111.00;
        })
            	// 获取结果后, 转换为String
                .thenApply(String::valueOf)
            	// 然后将结果拼接price is
                .thenApply(str -> "price is " + str)
            	// 最后打印方法
                .thenAccept(System.out::println);
        
        System.in.read();
    }
}
```

**该Demo还未完善**

```java

public class CompletableFutureDemo_02 {

    static Double priceFromTB(){
        try {
            Thread.sleep(1001);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return 1.0;
    }

    static Double priceFromJD(){
        try {
            Thread.sleep(1222);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return 22.0;
    }

    static Double priceFromTM(){
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return 3.21;
    }

    public static void main(String[] args) {
        CompletableFuture<Double>futureTM = CompletableFuture.supplyAsync(() -> priceFromTM());
        CompletableFuture<Double>futureTB = CompletableFuture.supplyAsync(() -> priceFromTB());
        CompletableFuture<Double>futureJD = CompletableFuture.supplyAsync(() -> priceFromJD());

        CompletableFuture.allOf(futureTM, futureTB, futureJD).join();

        System.out.println("end");
    }
}
```

# ThreadPool

## 简单的线程Demo

```java
public class HelloThreadPool {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService service = Executors.newCachedThreadPool();
        FutureTask<String> futureTask = new FutureTask<>(() -> "HelloWorld");
        service.submit(futureTask);

        System.out.println(futureTask.get());

        service.shutdown();
    }
}
```

## 线程池中的参数

```java
class ThreadPoolExecutorDemo {
    public static void main(String[] args) {
        /*
         *  corePoolSize 线程池的核心线程数
         *              核心线程的生命周期是跟随线程池的, 不会因为空闲被回收
         *              当有任务来的时候, 如果没有线程就申请一个, 如果核心线程都满了, 就进入阻塞队列
         *  maximumPoolSize 线程池的最大线程数量
         *              当核心线程不够用, 并且阻塞队列都满了, 线程数已经到达最大线程数, 就无法再申请线程, 进入拒绝策略
         *  keepAliveTime 线程的存活时间
         *              当非核心线程, 空闲没有被操作的时间达到, 这个数值, 就会被回收, 节省资源
         *  workQueue 线程阻塞队列
         *              当核心线程都满了, 线程就会进入阻塞队列, 等待新的线程来执行
         *  handler 拒绝策略
         *              当阻塞队列满了, 并且线程池中的线程数已经达到Max, 那么就会执行拒绝策略
         *              JDK提供了四中共拒绝策略:
         *                  1.AbortPolicy 直接抛出异常
         *                  2.DiscardOldestPolicy 丢弃任务队列中最早的任务, 然后将task加入队列
         *                  3.DiscardPolicy 直接丢弃改任务
         *                  4.CallerRunsPolicy 那个线程调用了execute方法, 那个线程就执行该任务
         */
        ThreadPoolExecutor pool = new ThreadPoolExecutor(2, 4,
                60, TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(4),
                new ThreadPoolExecutor.DiscardOldestPolicy());

        new ThreadPoolExecutor.AbortPolicy();
        new ThreadPoolExecutor.DiscardOldestPolicy();
        new ThreadPoolExecutor.DiscardPolicy();
        new ThreadPoolExecutor.CallerRunsPolicy();

        pool.submit(() -> System.out.println("Hello ThreadPool"));

        pool.shutdown();
    }
}
```

## SingleThreadPool

```java
public class FixedThreadPoolDemo {
    public static void main(String[] args) {
        ExecutorService service = Executors.newFixedThreadPool(10);
        for (int i = 0; i < 10; i++) {
            int finalI = i;
            service.execute(() -> System.out.println(finalI));
            System.out.println(service);// 输入线程池的状态
        }
        service.shutdown();
    }
}

// JDK源码 -> 创建了一个核心线程数和最大线程数都为1的线程池
// 没有非核心线程, 所以没有存货时间这一概念
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

## CacheThreadPool

```java
public class CachedThreadPoolDemo {
    public static void main(String[] args) {
        // 缓存线程池, 没有核心线程数, 任务队列是SynchronousQueue, 因此来一个任务就直接使用 新的或空闲的线程
        ExecutorService service = Executors.newCachedThreadPool();
        for (int i = 0; i < 5; i++) {
            int finalI = i;
            service.execute(() -> System.out.println(finalI));
        }
        service.shutdown();
    }
}

// JDK源码 -> 创建了一个核心线程数为0个, 最先线程数为Integer.MAX_VALUE, 存货时间60秒的线程池
// 没有核心线程, 所以本身不适合并发量比较平稳的场景, 更加适合并发量不稳定的场景
// 使用的是SynchronousQueue, 所以来一个任务, 就会新建线程或使用空闲线程, 没有等待队列
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

## FixedThreadPool

```java
public class FixedThreadPoolDemo {
    public static void main(String[] args) {
        ExecutorService service = Executors.newFixedThreadPool(10);
        for (int i = 0; i < 10; i++) {
            int finalI = i;
            service.execute(() -> System.out.println(finalI));
            System.out.println(service);// 输入线程池的状态
        }
        service.shutdown();
    }
} 

// JDK源码 -> 创建了一个核心线程数与最大线程数一样的线程池, 全部都是核心线程, 因此没有存活时间这一概念
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

## WorkStealingPool

```java
public class WorkStealingPoolDemo {
    public static void main(String[] args) throws IOException {
        // WorkStealingPool 底层就是一个ForkJoinPool
        // 为ForkJoinPool提供了一个简单的实现, 但是没有ForkJoin框架强大的Fork计算功能
        ExecutorService service = Executors.newWorkStealingPool();
        for (int i = 0; i < 5; i++) {
            service.submit(() -> {
                System.out.println(Runtime.getRuntime().availableProcessors());
                System.out.println(Thread.currentThread().getName() + " " + Thread.currentThread().isDaemon());
            });
        }
        // WorkStealingPool 创建的都是守护线程, 不会阻塞main线程, 所以这里必须阻塞才能看到运行结果
        System.in.read();
    }
}
```

## ForkJoinPool

### RecursiveAction

没有返回值的ForkJoinTask实现类, 可以Fork计算

### RecursiveTask\<T\>

有返回值的ForkJoinTask实现类, 可以Fork计算

```java
public class ForkJoinPoolDemo {
    static long[] nums = new long[10000000];
    static final int MAX_NUM = 50000;
    static Random r = new Random();

    // 初始化数组
    static {
        for (int i = 0; i < nums.length; i++) {
            nums[i] = r.nextInt();
        }

        System.out.println(Arrays.stream(nums).sum());
    }

    // 无返回值的可分叉任务
    static class SumTaskNoReturn extends RecursiveAction {

        int start, end;

        public SumTaskNoReturn(int start, int end) {
            this.start = start;
            this.end = end;
        }

        @Override
        protected void compute() {
            // 达到规定的区间内
            if (end - start <= MAX_NUM) {
                long sum = 0L;
                for (int i = start; i < end; i++) {
                    sum += nums[i];
                }
                System.out.println("form: " + start + " to " + end + " = " + sum);
            } else {
                int mid = start + (end - start >> 1);
                SumTaskNoReturn leftTask = new SumTaskNoReturn(start, mid);
                SumTaskNoReturn rightTask = new SumTaskNoReturn(mid, end);
                leftTask.fork();
                rightTask.fork();
            }
        }
    }

    // 有返回值的分差任务
    static class SumTaskReturn extends RecursiveTask<Long> {

        int start, end;

        public SumTaskReturn(int start, int end) {
            this.start = start;
            this.end = end;
        }

        @Override
        protected Long compute() {
            if (end - start <= MAX_NUM) {
                return Arrays.stream(nums).skip(start).limit(end - start).sum();
            } else {
                int mid = start + (end - start >> 1);
                SumTaskReturn leftTask = new SumTaskReturn(start, mid);
                SumTaskReturn rightTask = new SumTaskReturn(mid, end);

                leftTask.fork();
                rightTask.fork();

                return leftTask.join() + rightTask.join();
            }
        }
    }


    public static void main(String[] args) throws IOException, ExecutionException, InterruptedException {
        ForkJoinPool forkJoinPool = new ForkJoinPool();
//        SumTaskNoReturn sumTaskNoReturn = new SumTaskNoReturn(0, nums.length);
        SumTaskReturn sumTaskReturn = new SumTaskReturn(0, nums.length);
        forkJoinPool.submit(sumTaskReturn);
        System.out.println(sumTaskReturn.join());
//        System.in.read();
//        forkJoinPool.shutdown();
    }

}
```

# JMH Java Microbenchmark Harness

## 基本注解

- Benchmark

  - > 该注解放在方法上表示这是一个需要JMH的测试方法

- Warmup

  - >该注解用来控制程序预热, 进行 JIT 优化

  - iterations

    - 表示预热次数

  - time

    - 间隔时间

- Fork

  - >多少个线程同时执行, 测试多少次, 依次添加一个线程运行, 提高CPU(线程) 使用率

- BenchmarkMode

  - >基准测试模式

- Measurement

  - >控制测试次数, 间隔时间等



> #### 测试串行计算素数和并行计算素数的效率

```java
public class ParallelStreamDemo {
    public static ArrayList<Integer> list = new ArrayList<>();

    static {
        for (int i = 0; i < 1000; i++) {
            list.add(1000000 + new Random().nextInt(1000000));
        }
    }

    public static void foreach() {
        list.forEach(ParallelStreamDemo::isPrime);
    }

    public static void parallelForeach() {
        list.parallelStream().forEach(ParallelStreamDemo::isPrime);
    }

    public static boolean isPrime(int num) {
        return Stream.iterate(2, item -> ++item).limit((int) Math.sqrt(num)).allMatch(item -> num % item != 0);
    }

}
```

```java
public class ParallelStreamTest {
    @Benchmark // 基准测试注解
    @Warmup(iterations = 2, time = 5) // 程序预热, JIT优化
    @Fork(8) // 使用多少个线程执行程序, 测试多少次, 依次多添加一个线程运行, 提高CPU(线程)使用率
    @BenchmarkMode(Mode.Throughput) // 基准测试模式
    @Measurement(iterations = 5, time = 3)
    public void testForeach(){
        ParallelStreamDemo.foreach();
    }

    @Benchmark // 基准测试注解
    @Warmup(iterations = 2, time = 5) // 程序预热, JIT优化
    @Fork(8) // 使用多少个线程执行程序, 测试多少次, 依次多添加一个线程运行, 提高CPU(线程)使用率
    @BenchmarkMode(Mode.Throughput) // 基准测试模式
    @Measurement(iterations = 5, time = 3)
    public void testParallelForeach(){
        ParallelStreamDemo.parallelForeach();
    }
}
```

[单线程计算log](./log-single.log)

[多线程计算log](./log-parallel.log)

