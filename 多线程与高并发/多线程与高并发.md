# 创建线程的方式

| Method           | Describe                                               |
| ---------------- | ------------------------------------------------------ |
| 继承Thread类     | 继承重写run方法, 耦合了父类,受限于单继承,不建议使用    |
| 实现Runnable接口 | 实现run方法, Runable是可以重用, 解耦了逻辑代码和Thread |
| 使用线程池       | ...                                                    |

# synchronized

当某个方法或者某个方法块被夹了sync后, 就相当于给代码加了锁(一个对象, 任意的单例对象), 只有获取锁之后才能运行代码, 

锁本身是互斥的, 一个锁只能被一个线程获取.

下面是经典的抢票和脏读案例

```java
//多线程抢票
public class TicketMachine {
    
    int count = 100;

    //加上synchronized实现数据安全
    public void sell(){
        if(count > 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+"抢到了第"+count+"张票,"+"当前剩余票数:"+--count);
        }
    }

    public static void main(String[] args) {
        TicketMachine tm = new TicketMachine();
        new Thread(() -> {
            for(int i = 0; i < 50; i++){
                tm.sell();
            }
        },"Marry").start();
        new Thread(() -> {
            for(int i = 0; i < 50; i++){
                tm.sell();
            }
        },"Jerry").start();
    }
}


```

```java
//脏读案例
public class Account {
    String name;
    Double balance;

    public synchronized void setBalance(Double balance) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.balance = balance;
    }

        public Double getBalance() {
        return balance;
    }

    public static void main(String[] args) {
        Account account = new Account();
        account.name = "杨水马";
        new Thread(() -> {
            account.setBalance(100.);
        }).start();
        new Thread(() -> {
            System.out.println("读方法没有加锁, 获取的值为:" + account.getBalance()
                    + (account.getBalance() == null ? "---程序出现了脏读" : ""));
        }).start();
        try {
            Thread.sleep(1200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(account.getBalance());
    }
}
```

- #### sync加在方法上默认锁的是this,sync可重复锁,在调用父类sync方法时,锁的还是子类的this

- #### sync中如果出现异常,程序会释放锁,如果不想释放,需要catch异常

## sync不要使用String常量,Integer,Long.....

sync锁订String常量,  可能会使其他使用到该String常量的lib出现问题

Integer..等, 在代码里做了特殊处理, 在操作时,可能改变对象信息

## sync锁升级

> JDK早起sync是重量级锁, 多线程访问时, 直接向操作系统申青进入等待队列
>
> JVM没有规定sync如何实现, 下面的案例是hotspot的sync实现

在第一个线程访问资源时, 在对象头添加一个标记, markword, 用来记录该线程的pid, 如果下一次还是同一个线程(同样的pid)来访问资源, 

那么就不用再去申请锁了, 直接访问资源 ---> **`偏向锁`**

如果第二次访问的线程不是同一线程, 那么他不会立马去操作系统的等待队列, 他会在原地等待(循环) , 在循环的没有结束之前,

如果锁被释放了, 那么该线程就可以抢锁继续执行 ---> **`自旋锁`**

等待循环10次后, 还没有获取资源, 此时就会想操作系统申请, 进入等待队列 ---> **`重量级锁`**

- **自旋锁适合于执行时间短,并且并发量不高的情况**
  - **如果并发量太高,太多线程自旋,浪费资源**
  - **如果线程执行时间长,那么自旋获取锁概率低,不适合使用自旋锁**

# volatile

**volatile关键字可以让变量在多个线程中共享(多个线程中都可见), 在任意一个线程更改变量后, 别的线程中的这个变量会立马更新**

**volatile同时也可以禁止指令重排序**



## volatile变量可见性

```java
public class VolatileVarVisible extends Thread{
    public boolean flag = true;

    public void run(){
        System.out.println("server start");
        while(flag){
            //模拟服务器运行
        }
        System.out.println("server end");
    }
    
    public static void main(String[] args) {
        VolatileVarVisible server = new VolatileVarVisible();
        //启动服务器
        server.start();
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //两秒后设置flag为false, 让服务器停止运行
        server.flag = false;
    }
}
```

上面的代码在预期中, 服务器启动,运行两秒后,应该会关闭,输出server end

但是实际执行中, 两秒后并没有关闭, 并且等待n秒后仍在运行

- **没有关闭的原因是:**
  - **这个案例中, 有一个main线程,和一个自定义的线程, 这个两个线程都要访问server对象的flag字段**
  - **JVM会将这个两个变量复制一份到各自的线程栈中, 当main方法更改flag时,更改的是自己的线程栈中的flag**
  - **然后会将flag的值同步到server对象中的flag, 但是这个操作对于另一个线程是不可见的**
  - **另一个线程并不知道flag更改了, 同时我们也无法确定它什么时候回去更新flag的数据**
  - **正因此出现了不同线程栈中的flag变量不一致的问题**
  - **为了保障操作的原子性,一致性, volatile关键字可以让对flag的操作,所有线程都可见**
  - **任意一个线程中的flag更改都会直接反映到其他线程中**

- ## volatile保证变量在多线程中是可见的, 依赖于CPU的MESI,缓存一致性协议

MESI中每个缓存行都有四个状态，分别是E（exclusive）、M（modified）、S（shared）、I（invalid）。下面我们介绍一下这四个状态分别代表什么意思。

M：代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中。这个状态的缓存行中的数据和内存中的不一样，在未来的某个时刻它会被写入到内存中（当其他CPU要读取该缓存行的内容时。或者其他CPU要修改该缓存对应的内存中的内容时（个人理解CPU要修改该内存时先要读取到缓存中再进行修改），这样的话和读取缓存中的内容其实是一个道理）。

E：E代表该缓存行对应内存中的内容只被该CPU缓存，其他CPU没有缓存该缓存对应内存行中的内容。这个状态的缓存行中的内容和内存中的内容一致。该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。

S:该状态意味着数据不止存在本地CPU缓存中，还存在别的CPU的缓存中。这个状态的数据和内存中的数据是一致的。当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态

|    当前状态    |                             事件                             |                             行为                             | 下一个状态 |
| :------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :--------: |
|  I（invalid）  |                          local read                          | 1.如果其他处理器中没有这份数据，本缓存从内存中取该数据，状态变为E2.如果其他处理器中有这份数据，且缓存行状态为M，则先把缓存行中的内容写回到内存。本地cache再从内存读取数据，这时两个cache的状态都变为S3.如果其他缓存行中有这份数据，并且其他缓存行的状态为S或E，则本地cache从内存中取数据，并且这些缓存行的状态变为S |    E或S    |
|                |                         local write                          | 1.先从内存中取数据，如果其他缓存中有这份数据，且状态为M，则先将数据更新到内存再读取（个人认为顺序是这样的，其他CPU的缓存内容更新到内存中并且被本地cache读取时，两个cache状态都变为S，然后再写时把其他CPU的状态变为I，自己的变为M）2.如果其他缓存中有这份数据，且状态为E或S，那么其他缓存行的状态变为I |     M      |
|  remote read   |               remote read不影响本地cache的状态               |                              I                               |            |
|  remote write  |               remote read不影响本地cache的状态               |                              I                               |            |
| E（exclusive） |                          local read                          |                           状态不变                           |     E      |
|                |                         local write                          |                          状态变为M                           |     M      |
|  remote read   |                 数据和其他核共享，状态变为S                  |                              S                               |            |
|  remote write  |                 其他CPU修改了数据，状态变为I                 |                              I                               |            |
|  S（shared）   |                          local read                          |                          不影响状态                          |     S      |
|                |                         local write                          |         其他CPU的cache状态变为I，本地cache状态变为M          |     M      |
|  remote read   |                          不影响状态                          |                              S                               |            |
|  remote write  |      本地cache状态变为I，修改内容的CPU的cache状态变为M       |                              I                               |            |
| M（modified）  |                          local read                          |                           状态不变                           |     M      |
|                |                         local write                          |                           状态不变                           |     M      |
|  remote read   | 先把cache中的数据写到内存中，其他CPU的cache再读取，状态都变为S |                              S                               |            |
|  remote write  | 先把cache中的数据写到内存中，其他CPU的cache再读取并修改后，本地cache状态变为I。修改的那个cache状态变为M |                              I                               |            |

## volatile防止指令重排

> 防止指令重排最典型的例子就是单例模式中的 双重检测

```java
public class Manager {

    private volatile static Manager instance;

    private Manager(){
        System.out.println("smm");
    }

    public static Manager getInstance(){
        if(instance == null){
            synchronized (Manager.class) {
                if(instance == null){
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    instance = new Manager();
                }
            }
        }
        return instance;
    }
}
class TestManager{
    public static void main(String[] args) {
        new Thread(() -> {
            for(int i = 0; i < 100; i++){
                Manager m = Manager.getInstance();
                System.out.println(m.hashCode());
            }
        }).start();
        new Thread(() -> {
            for(int i = 0; i < 100; i++){
                Manager m = Manager.getInstance();
                System.out.println(m.hashCode());
            }
        }).start();
    }
}
```

指令重排非常难演示出来, 他一般都只会出现在JIT优化, 或者非常非常高的并发情况下(如秒杀)

- **指令重排的概念:**
- **赋值一个变量可以分为三个步骤**
  1. **首先申请内存初始化变量,里面存放的是初始值**    &0x1025fe = init;
  2. **然后变量赋值为我们想要的值**    &0x1025fe = MyValue;
  3. **最后将指针指向该变量**   point = &0x1025fe;
  4. **在没有完成第三步的时候, 可以将point理解为point=null**
- **编译器为了优化, 可能会进行指令重排, 将第三部提前到第二步**
  - **这个时候在第二步中, point的值已经不为null了, 他指向&0x1025fe, 里面存放的是初始值**
  - **如果在执行到第二部还没有执行第三部的时候, 有一个线程进入到point == null, 此时的结果为true**
  - **这个时候获取的值是一个初始值, 如果对他进行处理就可能会影响程序逻辑,导致错误**
  - **volatile禁止指令重排就解决了该问题**

# CAS

CAS(CompareAndSwap or CompareAndSet)

CAS就是所谓的自旋锁/乐观锁

CAS是无锁并发, 因此性能高

JUC包下所有的Atomic开头的类都是CAS操作

## AtomicInteger

```java
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

public class IntegerIncrement {
    AtomicInteger count = new AtomicInteger(0);

    public void m(){
        for (int i = 0; i < 100000; i++) {
            count.incrementAndGet();
        }
    }

    public static void main(String[] args) {
        IntegerIncrement integerIncrement = new IntegerIncrement();
        List<Thread> list = new ArrayList<>();
        for(int i = 0; i < 10; i++){
            list.add(new Thread(integerIncrement::m));
        }
        list.forEach(Thread::start);
        for (Thread thread : list) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(integerIncrement.count);
    }
}
```

**CAS底层实现原理就是 判断一个值是否与预期值一致, 如果一致, 就代表当前变量没有被其他线程更改, 直接更改即可**

**到这里你可能会有疑问, 在判断是否与预期值一致时, 不会有其他线程抢占吗?**

**答案是不会, 因为这个比较的过程(CAS), 是CPU原语, 是一条原子性的指令, 不会出现线程抢占执行**

下面是AtomicInteger, incrementAndGet方法的源码, 它调用了Unsafe类中的方法

```java
/**
 * Atomically increments by one the current value.
 *
 * @return the updated value
 */
public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}
```

```java
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
        //compareAndSwap就是我们所说的CAS, 它是CPU原语, 本身就是一条CPU指令, 是原子性操作
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
```

## LongAdder

**LongAdder 适合于多线程长期增加一个值**

```java
import java.util.concurrent.atomic.LongAdder;

public class LongAdderDemo {

    static LongAdder longAdder = new LongAdder();

    public static void main(String[] args) throws InterruptedException {
        LongAdderDemo l = new LongAdderDemo();
        Thread[] threads = new Thread[1000];
        for(int i = 0; i < threads.length; i++){
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    longAdder.increment();
                }
            });
        }

        for (Thread thread : threads) {
            thread.start();
        }

        for (Thread thread : threads) {
            thread.join();
        }

        System.out.println(longAdder.longValue());
    }
}

```





## ABA问题

ABA问题是指在CAS操作前, 如果已经有一个线程, 改变了变量, 然后又改回去, 可能会出现问题

- 例子:  
  1. 现在有一个`int a = 1`, 它在CAS前, 被其他线程更改为`100`, 然后又更改为`1`, 此时CAS判断预期值一致,继续执行更改  
     在变量为基础数据类型的情况下, 其实不会产生影响, 接下来该干嘛干嘛, 但是如果变量是引用数据类型就会出现问题了
  2. 有一个Obj对象, 在CAS前, 如果更改了CAS中的值, 但是在CAS时,Obj地址没变, 因此CAS会正常执行, 这样就会出现问题了,  
     想要解决这个问题, 只需要给对象加上一个版本号version即可, 每次更改对象的任意字段时都要更改version,   
     在CAS时要同时判断`预期值`,`版本号`

# JUC中的新锁

JUC中的新锁都是QAS,CAS实现的

## ReentrantLock

**`ReentrantLock`**是一个可重入锁, 这一点和sync一致

但是ReentrantLock拥有更多新特性, 相当于sync的扩展, 他可以代替sync

### lock()

```java
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockDemo {
    static long num = 0;

    static ReentrantLock rLock = new ReentrantLock();

    static void m(){
        for(int i = 0; i < 1000; i++){
            try {
                //使用lock()方法来锁定,lock()后面的方法限相当于sync(obj){},大括号中的代码块
                rLock.lock();
                num++;
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                //一定要try finally,保证会释放锁
                if (rLock != null) {
                    rLock.unlock();
                }
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[1000];
        for(int i = 0; i < threads.length; i++){
            threads[i] = new Thread(ReentrantLockDemo::m);
        }

        for (Thread thread : threads) {
            thread.start();
        }

        for (Thread thread : threads) {
            thread.join();
        }
        System.out.println(num);
    }
}
```

### tryLock()

ReentrantLock中提供了tryLock方法, 该方法可以指定尝试获取锁的过程, 可以等待(阻塞)多少秒, 超时后直接不再等待, 可以先去左其他事

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockDemo2 {
    static long num = 0;

    static ReentrantLock lock = new ReentrantLock();

    static void m(){
        try {
            lock.lock();
            //将会锁定>=10秒
            for (int i = 0; i < 10; i++) {
                Thread.sleep(1000);
                System.out.println(Thread.currentThread().toString()+ ++num);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    static void m2(){
        boolean bool = false;
        try {
            //尝试去获取锁, 如果阻塞时间超过5秒, 将会不再阻塞, 可以去做其他事
            bool = lock.tryLock(5, TimeUnit.SECONDS);
            System.out.println(Thread.currentThread()+"m2 lock is "+bool);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            //如果获取到了锁, 就释放锁
            if(bool) {
                System.out.println(++num);
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(ReentrantLockDemo2::m, "t1");
        Thread t2 = new Thread(ReentrantLockDemo2::m2, "t2");
        //演示需要让t1先执行, 设置最大优先级, 方便测试
        t1.setPriority(Thread.MAX_PRIORITY);
        t1.start();
        t2.start();
    }
}
```

### lockInterruptibly()

ReentrantLock支持可中断锁, 这一点与sync不同, 如果线程没有获取sync锁, 会一直阻塞无法中断的

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockDemo3 {
    static ReentrantLock lock = new ReentrantLock();

    static void m(){
        try {
            lock.lock();
            System.out.println(Thread.currentThread()+"--start");
            TimeUnit.SECONDS.sleep(10);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (lock != null) {
                lock.unlock();
            }
        }
        System.out.println(Thread.currentThread()+"--end");
    }

    static void m1(){
        try {
            //设置可中断锁
            lock.lockInterruptibly();
            System.out.println(Thread.currentThread()+"end");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }finally {
            if (lock != null) {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(ReentrantLockDemo3::m, "t1");
        Thread t2 = new Thread(ReentrantLockDemo3::m1, "t2");
        t1.setPriority(Thread.MAX_PRIORITY);//需要让t1先运行,为测试创造条件,不是100%优先执行,但是比没有好
        t1.start();
        t2.start();
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("t2 will be interrupted");
        //t1会执行10秒, 如果5秒后t2还没获取锁执行, 强行中断会抛出IllegalMonitorStateException异常
        t2.interrupt();
    }
}
```

### fair

ReentrantLock支持公平锁, 设置公平锁后, lock将会创建一个线程队列, 线程在队列中有序执行, 而不是队列中的线程抢锁

```java
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockDemo4 {
    //调用boolean参数的构造方法设置为true, 就可以使用公平锁, 默认为false公平锁
    static ReentrantLock lock = new ReentrantLock(true);

    static void m1(){
        for (int i = 0; i < 10; i++) {
            try {
                lock.lock();
                Thread.sleep(1000);
                System.out.println(Thread.currentThread().getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                if (lock != null) {
                    lock.unlock();
                }
            }
        }
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(ReentrantLockDemo4::m1,"t1");
        Thread t2 = new Thread(ReentrantLockDemo4::m1,"t2");
        t1.start();
        t2.start();
        //打印的结果不一定是想象中的两个线程交替执行, 实际结果可能是下面这样:
        /*
        		t2
                t2
                t2
                ....
                t1
                t2
                t1
                t1
        */
       	//原因其实也很简单, 当t1获取锁之后执行,这个时候t2进入等待队列, 然后第二次就是t2执行,这个没有问题,
        //如果执行某次时t1获取锁执行完成后, 它立马又被CPU调度,进入等待队列,然后t2才进入队列,这个时候t1就会有执行一遍了
    }
}
```

## CountDownLatch

CountDownLatch, 可以原子性的自减, 等到自减至0的时候继续执行

```java
import java.util.concurrent.CountDownLatch;

public class CountDownLatchDemo {
    //参数列表为计数
    static final CountDownLatch latch = new CountDownLatch(1000);

    public static void main(String[] args) {
        Thread[] threads = new Thread[1000];

        for(int i = 0; i < threads.length; i++){
            threads[i] = new Thread(() -> {
                System.out.println(Thread.currentThread().getName());
                //原子性的自减
                latch.countDown();
            });
        }

        for (Thread thread : threads) {
            thread.start();
        }

        try {
            //阻塞当前线程, 直到count自减至0
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(latch.getCount());
    }
}
```

## CyclicBarrier

CyclicBarrier循环壁垒, 只有当n个线程都进入执行队列后, 才会继续执行

```java
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierDemo {
    public static void main(String[] args) {
        //第一个参数指定线程数, 第二个为回调函数
        CyclicBarrier barrier = new CyclicBarrier(20, () -> System.out.println("run..."));
        for (int i = 0; i < 100; i++){
            new Thread(() -> {
                try {
                    //如果队列中未满20, 阻塞当前线程
                    barrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

## Exchanger

Exchanger可以交换两个线程作用域中的变量

```java
import java.util.concurrent.Exchanger;

public class ExchangerDemo {
    static Exchanger<String> exchanger = new Exchanger<>();

    public static void main(String[] args) {
        for(int i = 0; i < 2; i++){
            int finalI = i;
            new Thread(() -> {
                String str = "t"+finalI;
                try {
                    //调用exchanger, 指定需要交换的变量
                    str = exchanger.exchange(str);
                    System.out.println(Thread.currentThread().getName()+"="+str);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "t"+finalI).start();
        }
    }
}
```

## Phaser

Phaser可以将线程的执行过程分为多个阶段, 只有当多有线程都执行完成一个阶段后, 才会执行下一个阶段

```java
import java.util.ArrayList;
import java.util.concurrent.Phaser;

public class PhaserDemo {

    public static void main(String[] args) {
        ArrayList<Thread> list = new ArrayList<>();
        for(int i = 0; i < 8; i++){
            String name = "t"+i;
            list.add(new Thread(new Person(name),name));
        }
        //添加两个last线程, 只有last线程才需要执行doLast()
        list.add(new Thread(new Person("lastT1"),"lastT1"));
        list.add(new Thread(new Person("lastT2"),"lastT2"));
        //注册有多少个线程
        myPhaser.bulkRegister(list.size());
        list.forEach(Thread::start);
    }
    
    static MyPhaser myPhaser = new MyPhaser();

    //自定义一个阶段执行器
    static class MyPhaser extends Phaser{
        //方法返回值为true就会结束线程
        @Override
        protected boolean onAdvance(int phase, int registeredParties) {
            //phase每过一个阶段就会自增, 第一个阶段默认为0, 依次类推, 1,2...n
            switch (phase){
                case 0:
                    System.out.println("step one complete! Current nums of Threads:"+registeredParties+"\r\n");
                    return false;
                case 1:
                    System.out.println("step two complete! Current nums of Threads:"+registeredParties+"\r\n");
                    return false;
                case 2:
                    System.out.println("step Three complete! Current nums of Threads:"+registeredParties+"\r\n");
                    return false;
                case 3:
                    System.out.println("step Last complete! Current nums of Threads:"+registeredParties+"\r\n");
                    return true;
                default:
                    return true;
            }
        }
    }

    static void millisSleep(long millis){
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    //自定义一个Person, 有四个阶段的执行方法
    static class Person implements Runnable{
        String name;

        public Person(String name){this.name = name;}

        public void doOne(){
            millisSleep((long) (Math.random() * 1000));
            System.out.println(Thread.currentThread().getName()+"=step One");
            //到达当前阶段, 等待其他线程执行完成后, 才会进入下一个阶段继续执行
            myPhaser.arriveAndAwaitAdvance();
        }

        public void doTwo(){
            millisSleep((long) (Math.random() * 1000));
            System.out.println(Thread.currentThread().getName()+"=step Two");
            myPhaser.arriveAndAwaitAdvance();
        }

        public void doThree(){
            millisSleep((long) (Math.random() * 1000));
            System.out.println(Thread.currentThread().getName()+"=step Three");
            myPhaser.arriveAndAwaitAdvance();
        }

        public void doLast(){
            if(name.startsWith("last")){
                millisSleep((long) (Math.random() * 1000));
                System.out.println(Thread.currentThread().getName()+"=step Last");
                myPhaser.arriveAndAwaitAdvance();
            }else {
                //如果不是last线程, 到这一步的时候就会停止, 不会继续执行
                myPhaser.arriveAndDeregister();
            }
        }

        //线程执行的四个阶段
        @Override
        public void run() {
            doOne();
            doTwo();
            doThree();
            doLast();
        }
    }
}
```

## ReadWriteLock

```java
import java.util.Random;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockDemo {
    static int value = 0;

    //普通的可重入锁
    static Lock lock = new ReentrantLock();

    //读写锁
    static ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    //读锁
    static Lock readLock = readWriteLock.readLock();
    //写锁
    static Lock writeLock = readWriteLock.writeLock();

    //读取value的方法, 传入一个lock, 对比ReentrantLock和ReadWriteLock的效率
    static void read(Lock lock){
        try {
            lock.lock();
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName()+": value="+value);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (lock != null) {
                lock.unlock();
            }
        }
    }

    static void write(Lock lock, int newValue){
        try {
            lock.lock();
            System.out.println(Thread.currentThread().getName()+"value = "+(value = newValue));
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (lock != null) {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        //使用读写锁, 大幅提高读取性能
        for(int i = 0; i < 18; i++){
            new Thread(() -> read(readLock)).start();
        }
        for(int i = 0; i < 2; i++){
            new Thread(() -> write(writeLock, new Random().nextInt())).start();
        }
        //使用普通的Reentrant
        /*for(int i = 0; i < 18; i++){
            new Thread(() -> read(lock)).start();
        }
        for(int i = 0; i < 2; i++){
            new Thread(() -> write(lock,new Random().nextInt())).start();
        }*/
    }
}
```

## Semaphore

Semaphore信号锁

```java
import java.util.ArrayList;
import java.util.concurrent.Semaphore;

public class SemaphoreDemo {
    //传入一个int permits, 允许多少线程可以一起执行
    static Semaphore semaphore = new Semaphore(2);

    public static void main(String[] args) {
        ArrayList<Thread> list = new ArrayList<>();
        for(int i = 0; i < 5; i++){
            list.add(new Thread(() -> {
                try {
                    //获取锁
                    semaphore.acquire();
                    for(int j = 0; j < 5; j++){
                        Thread.sleep(300);
                        System.out.println(Thread.currentThread().getName()+": run...");
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    //释放锁
                    semaphore.release();
                }
            }));
        }
        list.forEach(Thread::start);
    }
}
```

