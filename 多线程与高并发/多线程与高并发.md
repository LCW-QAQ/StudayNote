# 创建线程的方式

| Method           | Describe                                               |
| ---------------- | ------------------------------------------------------ |
| 继承Thread类     | 继承重写run方法, 耦合了父类,受限于单继承,不建议使用    |
| 实现Runnable接口 | 实现run方法, Runable是可以重用, 解耦了逻辑代码和Thread |
| 使用线程池       | ...                                                    |

# synchronized

当某个方法或者某个方法块被夹了sync后, 就相当于给代码加了锁(一个对象, 任意的单例对象), 只有获取锁之后才能运行代码, 

锁本身是互斥的, 一个锁只能被一个线程获取.

下面是经典的抢票和脏读案例

```java
//多线程抢票
public class TicketMachine {
    
    int count = 100;

    //加上synchronized实现数据安全
    public void sell(){
        if(count > 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+"抢到了第"+count+"张票,"+"当前剩余票数:"+--count);
        }
    }

    public static void main(String[] args) {
        TicketMachine tm = new TicketMachine();
        new Thread(() -> {
            for(int i = 0; i < 50; i++){
                tm.sell();
            }
        },"Marry").start();
        new Thread(() -> {
            for(int i = 0; i < 50; i++){
                tm.sell();
            }
        },"Jerry").start();
    }
}


```

```java
//脏读案例
public class Account {
    String name;
    Double balance;

    public synchronized void setBalance(Double balance) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.balance = balance;
    }

        public Double getBalance() {
        return balance;
    }

    public static void main(String[] args) {
        Account account = new Account();
        account.name = "杨水马";
        new Thread(() -> {
            account.setBalance(100.);
        }).start();
        new Thread(() -> {
            System.out.println("读方法没有加锁, 获取的值为:" + account.getBalance()
                    + (account.getBalance() == null ? "---程序出现了脏读" : ""));
        }).start();
        try {
            Thread.sleep(1200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(account.getBalance());
    }
}
```

- #### sync加在方法上默认锁的是this,sync可重复锁,在调用父类sync方法时,锁的还是子类的this

- #### sync中如果出现异常,程序会释放锁,如果不想释放,需要catch异常

## sync不要使用String常量,Integer,Long.....

sync锁订String常量,  可能会使其他使用到该String常量的lib出现问题

Integer..等, 在代码里做了特殊处理, 在操作时,可能改变对象信息

## sync锁升级

> JDK早起sync是重量级锁, 多线程访问时, 直接向操作系统申青进入等待队列
>
> JVM没有规定sync如何实现, 下面的案例是hotspot的sync实现

在第一个线程访问资源时, 在对象头添加一个标记, markword, 用来记录该线程的pid, 如果下一次还是同一个线程(同样的pid)来访问资源, 

那么就不用再去申请锁了, 直接访问资源 ---> **`偏向锁`**

如果第二次访问的线程不是同一线程, 那么他不会立马去操作系统的等待队列, 他会在原地等待(循环) , 在循环的没有结束之前,

如果锁被释放了, 那么该线程就可以抢锁继续执行 ---> **`自旋锁`**

等待循环10次后, 还没有获取资源, 此时就会想操作系统申请, 进入等待队列 ---> **`重量级锁`**

- **自旋锁适合于执行时间短,并且并发量不高的情况**
  - **如果并发量太高,太多线程自旋,浪费资源**
  - **如果线程执行时间长,那么自旋获取锁概率低,不适合使用自旋锁**

# volatile

**volatile关键字可以让变量在多个线程中共享(多个线程中都可见), 在任意一个线程更改变量后, 别的线程中的这个变量会立马更新**

**volatile同时也可以禁止指令重排序**



## volatile变量可见性

```java
public class VolatileVarVisible extends Thread{
    public boolean flag = true;

    public void run(){
        System.out.println("server start");
        while(flag){
            //模拟服务器运行
        }
        System.out.println("server end");
    }
    
    public static void main(String[] args) {
        VolatileVarVisible server = new VolatileVarVisible();
        //启动服务器
        server.start();
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //两秒后设置flag为false, 让服务器停止运行
        server.flag = false;
    }
}
```

上面的代码在预期中, 服务器启动,运行两秒后,应该会关闭,输出server end

但是实际执行中, 两秒后并没有关闭, 并且等待n秒后仍在运行

- **没有关闭的原因是:**
  - **这个案例中, 有一个main线程,和一个自定义的线程, 这个两个线程都要访问server对象的flag字段**
  - **JVM会将这个两个变量复制一份到各自的线程栈中, 当main方法更改flag时,更改的是自己的线程栈中的flag**
  - **然后会将flag的值同步到server对象中的flag, 但是这个操作对于另一个线程是不可见的**
  - **另一个线程并不知道flag更改了, 同时我们也无法确定它什么时候回去更新flag的数据**
  - **正因此出现了不同线程栈中的flag变量不一致的问题**
  - **为了保障操作的原子性,一致性, volatile关键字可以让对flag的操作,所有线程都可见**
  - **任意一个线程中的flag更改都会直接反映到其他线程中**

- ## volatile保证变量在多线程中是可见的, 依赖于CPU的MESI,缓存一致性协议

MESI中每个缓存行都有四个状态，分别是E（exclusive）、M（modified）、S（shared）、I（invalid）。下面我们介绍一下这四个状态分别代表什么意思。

M：代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中。这个状态的缓存行中的数据和内存中的不一样，在未来的某个时刻它会被写入到内存中（当其他CPU要读取该缓存行的内容时。或者其他CPU要修改该缓存对应的内存中的内容时（个人理解CPU要修改该内存时先要读取到缓存中再进行修改），这样的话和读取缓存中的内容其实是一个道理）。

E：E代表该缓存行对应内存中的内容只被该CPU缓存，其他CPU没有缓存该缓存对应内存行中的内容。这个状态的缓存行中的内容和内存中的内容一致。该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。

S:该状态意味着数据不止存在本地CPU缓存中，还存在别的CPU的缓存中。这个状态的数据和内存中的数据是一致的。当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态

|    当前状态    |                             事件                             |                             行为                             | 下一个状态 |
| :------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :--------: |
|  I（invalid）  |                          local read                          | 1.如果其他处理器中没有这份数据，本缓存从内存中取该数据，状态变为E2.如果其他处理器中有这份数据，且缓存行状态为M，则先把缓存行中的内容写回到内存。本地cache再从内存读取数据，这时两个cache的状态都变为S3.如果其他缓存行中有这份数据，并且其他缓存行的状态为S或E，则本地cache从内存中取数据，并且这些缓存行的状态变为S |    E或S    |
|                |                         local write                          | 1.先从内存中取数据，如果其他缓存中有这份数据，且状态为M，则先将数据更新到内存再读取（个人认为顺序是这样的，其他CPU的缓存内容更新到内存中并且被本地cache读取时，两个cache状态都变为S，然后再写时把其他CPU的状态变为I，自己的变为M）2.如果其他缓存中有这份数据，且状态为E或S，那么其他缓存行的状态变为I |     M      |
|  remote read   |               remote read不影响本地cache的状态               |                              I                               |            |
|  remote write  |               remote read不影响本地cache的状态               |                              I                               |            |
| E（exclusive） |                          local read                          |                           状态不变                           |     E      |
|                |                         local write                          |                          状态变为M                           |     M      |
|  remote read   |                 数据和其他核共享，状态变为S                  |                              S                               |            |
|  remote write  |                 其他CPU修改了数据，状态变为I                 |                              I                               |            |
|  S（shared）   |                          local read                          |                          不影响状态                          |     S      |
|                |                         local write                          |         其他CPU的cache状态变为I，本地cache状态变为M          |     M      |
|  remote read   |                          不影响状态                          |                              S                               |            |
|  remote write  |      本地cache状态变为I，修改内容的CPU的cache状态变为M       |                              I                               |            |
| M（modified）  |                          local read                          |                           状态不变                           |     M      |
|                |                         local write                          |                           状态不变                           |     M      |
|  remote read   | 先把cache中的数据写到内存中，其他CPU的cache再读取，状态都变为S |                              S                               |            |
|  remote write  | 先把cache中的数据写到内存中，其他CPU的cache再读取并修改后，本地cache状态变为I。修改的那个cache状态变为M |                              I                               |            |

## volatile防止指令重排

> 防止指令重排最典型的例子就是单例模式中的 双重检测

```java
public class Manager {

    private volatile static Manager instance;

    private Manager(){
        System.out.println("smm");
    }

    public static Manager getInstance(){
        if(instance == null){
            synchronized (Manager.class) {
                if(instance == null){
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    instance = new Manager();
                }
            }
        }
        return instance;
    }
}
class TestManager{
    public static void main(String[] args) {
        new Thread(() -> {
            for(int i = 0; i < 100; i++){
                Manager m = Manager.getInstance();
                System.out.println(m.hashCode());
            }
        }).start();
        new Thread(() -> {
            for(int i = 0; i < 100; i++){
                Manager m = Manager.getInstance();
                System.out.println(m.hashCode());
            }
        }).start();
    }
}
```

指令重排非常难演示出来, 他一般都只会出现在JIT优化, 或者非常非常高的并发情况下(如秒杀)

- **指令重排的概念:**
- **赋值一个变量可以分为三个步骤**
  1. **首先申请内存初始化变量,里面存放的是初始值**    &0x1025fe = init;
  2. **然后变量赋值为我们想要的值**    &0x1025fe = MyValue;
  3. **最后将指针指向该变量**   point = &0x1025fe;
  4. **在没有完成第三步的时候, 可以将point理解为point=null**
- **编译器为了优化, 可能会进行指令重排, 将第三部提前到第二步**
  - **这个时候在第二步中, point的值已经不为null了, 他指向&0x1025fe, 里面存放的是初始值**
  - **如果在执行到第二部还没有执行第三部的时候, 有一个线程进入到point == null, 此时的结果为true**
  - **这个时候获取的值是一个初始值, 如果对他进行处理就可能会影响程序逻辑,导致错误**
  - **volatile禁止指令重排就解决了该问题**